# License for this file: MIT (expat)
# Copyright 2023, DLR Institute of System Dynamics and Control
#
# This file is included in Modia/models/HeatTranser.jl


# Structure holding the internal memory of the insulated rod
mutable struct InsulatedRodStruct{FloatType}
  # Parameters
  Ge::FloatType              # = lambda*A/dx
  Ge2::FloatType             # = 2*Ge
  k::FloatType               # = Ge / (c*rho*A*dx)
  T_init::Vector{FloatType}  # initial states

  # Internal states and state deriatives
  T::Vector{FloatType}       # states
  der_T::Vector{FloatType}   # state derivatives

  # Start index of state and state derivative vectors
  T_startIndex::Int
  
  InsulatedRodStruct{FloatType}() where {FloatType} = new()
end


# Called from @instantiateModel(..) before getDerivatives!(..) is generated
function build_InsulatedRod2!(model::AbstractDict, modelModule, FloatType, TimeType, instantiateModelOptions, ID, pathAST)
    unitless = instantiateModelOptions[:unitless]
    model = model | Model(
        insRod  = Var(hideResult=true),  # InsulatedRodStruct instance (an equation to return this variable is generated by _buildFunction)
        success = Var(hideResult=true),  # Dummy return argument
        equations = :[
            # copy states into insRod.T and return insRod
            insRod = openInsulatedRod!(instantiatedModel, $ID)
      
            # equations at the boundaries
            port_a.Q_flow = getGe2(insRod, Val($unitless))*(port_a.T - getT1(  insRod, Val($unitless)))
            port_b.Q_flow = getGe2(insRod, Val($unitless))*(port_b.T - getTend(insRod, Val($unitless)))

            # compute insRod.der_T and copy it into state derivatives
            success = computeInsulatedRodDerivatives!(instantiatedModel, insRod, port_a.T, port_b.T)   # instantiatedModel is provided in the generated code
        ])

  return (model, InsulatedRodStruct{FloatType}())
end


# Called once before initialization of first simulation segment
function initFirstSegment_InsulatedRod2!(obj::InsulatedRodStruct{FloatType}; L, A, rho, lambda, c, T0, nT)::Nothing where {FloatType}
    # Convert to SI units, strip units and check that values are positives
    #=
    @show L
    @Modia.strippedPositive!(path, L)
    @Modia.strippedPositive!(path, A)
    @Modia.strippedPositive!(path, rho)
    @Modia.strippedPositive!(path, lambda)
    @Modia.strippedPositive!(path, c)
    @Modia.strippedPositive!(path, T0)
    @Modia.strippedPositive!(path, nT)
    @show L
    @show A
    @show rho
    @show lambda
    =#
    L      = stripUnit(L)
    A      = stripUnit(A)
    rho    = stripUnit(rho)
    lambda = stripUnit(lambda)
    c      = stripUnit(c)
    T0     = stripUnit(T0)

    # Compute derived parameters
    dx         = L/nT
    obj.Ge     = lambda*A/dx
    obj.Ge2    = 2*obj.Ge
    obj.k      = obj.Ge / ( c*rho*A*dx )
    obj.T_init = fill(T0, nT)

    # Allocate and initialize internal states
    obj.T      = copy(obj.T_init)
    obj.der_T  = zeros(nT)
    return nothing
end


# Called once before initialization of a new simulation segment
function initSegment_InsulatedRod2!(instantiatedModel::InstantiatedModel{FloatType,TimeType}, path::String, ID,
                                    parameters::AbstractDict; log=false)::Nothing where {FloatType,TimeType}
    obj::InsulatedRodStruct{FloatType} = Modia.get_instantiatedSubmodel(instantiatedModel, ID)
    
    if Modia.isFirstInitialOfAllSegments(instantiatedModel)
        initFirstSegment_InsulatedRod2!(obj; parameters...)
    end

    # Define a vector of new state and state derivative variables
    obj.T_startIndex = Modia.new_x_segmented_variable!(instantiatedModel, path*".T", path*".der(T)", obj.T, "K")
    return nothing
end


# Open an initialized InsulatedRod2 model and return a reference to it
function openInsulatedRod!(instantiatedModel::InstantiatedModel{FloatType,TimeType}, ID)::InsulatedRodStruct{FloatType} where {FloatType,TimeType}
    obj::InsulatedRodStruct{FloatType} = Modia.get_instantiatedSubmodel(instantiatedModel, ID)
    Modia.copy_Vector_x_segmented_value_from_state(instantiatedModel, obj.T_startIndex, obj.T)
    return obj
end


# Functions to inquire values from InsulatedRodStruct
getT1(  insRod::InsulatedRodStruct, Unitless::Val{true})  = insRod.T[1] 
getT1(  insRod::InsulatedRodStruct, Unitless::Val{false}) = insRod.T[1]*u"K"

getTend(insRod::InsulatedRodStruct, Unitless::Val{true})  = insRod.T[end] 
getTend(insRod::InsulatedRodStruct, Unitless::Val{false}) = insRod.T[end]*u"K"

getGe2( insRod::InsulatedRodStruct, Unitless::Val{true})  = insRod.Ge2
getGe2( insRod::InsulatedRodStruct, Unitless::Val{false}) = insRod.Ge2*u"W/K"

T_grad1(T,Ta,i) = if i == 1        ; (Ta - T[1])*2 else T[i-1] - T[i] end
T_grad2(T,Tb,i) = if i == length(T); (T[i] - Tb)*2 else T[i] - T[i+1] end

function computeInsulatedRodDerivatives!(instantiatedModel, obj::InsulatedRodStruct{FloatType}, Ta, Tb)::Bool where {FloatType}
    Ta::FloatType = stripUnit(Ta)
    Tb::FloatType = stripUnit(Tb)
    T  = obj.T
    k  = obj.k
    for i in 1:length(T)
        obj.der_T[i] = k*(T_grad1(T,Ta,i) - T_grad2(T,Tb,i))
    end
    Modia.copy_der_x_segmented_value_to_state(instantiatedModel, obj.T_startIndex, obj.der_T)
    return true
end
