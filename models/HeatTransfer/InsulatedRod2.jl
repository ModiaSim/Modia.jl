# License for this file: MIT (expat)
# Copyright 2023, DLR Institute of System Dynamics and Control
#
# This file is included in Modia/models/HeatTranser.jl


# Structure holding the internal memory of the insulated rod
mutable struct InsulatedRodStruct{FloatType}
  # Parameters
  path::String               # path name of instance
  Ge::FloatType              # = lambda*A/dx
  Ge2::FloatType             # = 2*Ge
  k::FloatType               # = Ge / (c*rho*A*dx)
  T_init::Vector{FloatType}  # initial states

  # Internal states and state deriatives
  T::Vector{FloatType}       # states
  der_T::Vector{FloatType}   # state derivatives

  # Start index of state and state derivative vectors
  T_startIndex::Int

  InsulatedRodStruct{FloatType}(path::String) where {FloatType} = new(path,false)
end


# Called once before initialization of first simulation segment
function initInsulatedRod2!(obj::InsulatedRodStruct{FloatType}; L, A, rho, lambda, c, T0, nT)::Nothing where {FloatType}
    #L, A, rho=7500.0u"kg/m^3", lambda=74.0u"W/(m*K)", c=450.0u"J/(kg*K)", T0=293.15u"K", nT=1)::Nothing where {FloatType}

    # Convert to SI units, strip units and check that values are positives
    path = obj.path
    #=
    @show L
    @Modia.strippedPositive!(path, L)
    @Modia.strippedPositive!(path, A)
    @Modia.strippedPositive!(path, rho)
    @Modia.strippedPositive!(path, lambda)
    @Modia.strippedPositive!(path, c)
    @Modia.strippedPositive!(path, T0)
    @Modia.strippedPositive!(path, nT)
    @show L
    @show A
    @show rho
    @show lambda
    =#
    L      = stripUnit(L)
    A      = stripUnit(A)
    rho    = stripUnit(rho)
    lambda = stripUnit(lambda)
    c      = stripUnit(c)
    T0     = stripUnit(T0)

    # Compute derived parameters
    dx         = L/nT
    obj.Ge     = lambda*A/dx
    obj.Ge2    = 2*obj.Ge
    obj.k      = obj.Ge / ( c*rho*A*dx )
    obj.T_init = fill(T0, nT)

    # Allocate and initialize internal states
    obj.T      = copy(obj.T_init)
    obj.der_T  = zeros(nT)
    return nothing
end


# Called from @instantiateModel(..) before getDerivatives!(..) is generated
function buildInsulatedRod2!(model::AbstractDict, FloatType, TimeType, unitless::Bool, buildDict, path)
    pathAsString = Modia.modelPathAsString(path)
    extraModelCode = Model(  # extra code to be merged with model
        insRod  = Var(hideResult=true),  # InsulatedRodStruct instance (an equation to return this variable is generated by _buildFunction)
        success = Var(hideResult=true),  # Dummy return argument
        equations = :[
            # copy states into insRod.T and return insRod
            insRod = openInsulatedRod!(instantiatedModel, $pathAsString)
      
            # equations at the boundaries
            port_a.Q_flow = getGe2(insRod, Val($unitless))*(port_a.T - getT1(  insRod, Val($unitless)))
            port_b.Q_flow = getGe2(insRod, Val($unitless))*(port_b.T - getTend(insRod, Val($unitless)))

            # compute insRod.der_T and copy it into state derivatives
            success = computeInsulatedRodDerivatives!(instantiatedModel, insRod, port_a.T, port_b.T)   # instantiatedModel is provided in the generated code
        ])

  # Store build info in buildDict
  buildDict[pathAsString] = InsulatedRodStruct{FloatType}(pathAsString)
  return extraModelCode
end


# Called once before initialization of a new simulation segment
function initInsulatedRod2ForNewSegment!(instantiatedModel::SimulationModel{FloatType,TimeType},
                                         parameters::AbstractDict, path::String; log=false)::Nothing where {FloatType,TimeType}
    obj::InsulatedRodStruct{FloatType} = instantiatedModel.buildDict[path]

    if Modia.isFirstInitialOfAllSegments(instantiatedModel)
        initInsulatedRod2!(obj; parameters...)
    end

    # Define a vector of new state and state derivative variables
    obj.T_startIndex = Modia.new_x_segmented_variable!(instantiatedModel, path*".T", path*".der(T)", obj.T, "K")
    return nothing
end


# Open an initialized InsulatedRod2 model and return a reference to it
function openInsulatedRod!(instantiatedModel::SimulationModel{FloatType,TimeType}, path::String)::InsulatedRodStruct{FloatType} where {FloatType,TimeType}
    obj::InsulatedRodStruct{FloatType} = instantiatedModel.buildDict[path]
    Modia.get_Vector_x_segmented_value!(instantiatedModel, obj.T_startIndex, obj.T)
    return obj
end


# Functions to inquire values from InsulatedRodStruct
getT1(  insRod::InsulatedRodStruct, Unitless::Val{true})  = insRod.T[1] 
getT1(  insRod::InsulatedRodStruct, Unitless::Val{false}) = insRod.T[1]*u"K"

getTend(insRod::InsulatedRodStruct, Unitless::Val{true})  = insRod.T[end] 
getTend(insRod::InsulatedRodStruct, Unitless::Val{false}) = insRod.T[end]*u"K"

getGe2( insRod::InsulatedRodStruct, Unitless::Val{true})  = insRod.Ge2
getGe2( insRod::InsulatedRodStruct, Unitless::Val{false}) = insRod.Ge2*u"W/K"

T_grad1(T,Ta,i) = if i == 1        ; (Ta - T[1])*2 else T[i-1] - T[i] end
T_grad2(T,Tb,i) = if i == length(T); (T[i] - Tb)*2 else T[i] - T[i+1] end

function computeInsulatedRodDerivatives!(instantiatedModel, obj::InsulatedRodStruct{FloatType}, Ta, Tb)::Bool where {FloatType}
    Ta::FloatType = stripUnit(Ta)
    Tb::FloatType = stripUnit(Tb)
    T  = obj.T
    k  = obj.k
    for i in 1:length(T)
        obj.der_T[i] = k*(T_grad1(T,Ta,i) - T_grad2(T,Tb,i))
    end
    Modia.add_der_x_segmented_value!(instantiatedModel, obj.T_startIndex, obj.der_T)
    return true
end
