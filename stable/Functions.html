<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · Modia</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Modia</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="tutorial/Tutorial.html">Modia Tutorial</a></li><li><a class="tocitem" href="tutorial/GettingStarted.html">1 Getting Started</a></li><li><a class="tocitem" href="tutorial/Modeling.html">2 Modeling</a></li><li><a class="tocitem" href="tutorial/Simulation.html">3 Simulation</a></li><li><a class="tocitem" href="tutorial/FloatingPointTypes.html">4 Floating Point Types</a></li><li><a class="tocitem" href="tutorial/Appendix.html">Appendix A</a></li></ul></li><li class="is-active"><a class="tocitem" href="Functions.html">Functions</a><ul class="internal"><li><a class="tocitem" href="#Instantiation"><span>Instantiation</span></a></li><li><a class="tocitem" href="#Simulation"><span>Simulation</span></a></li><li><a class="tocitem" href="#Linearization"><span>Linearization</span></a></li><li><a class="tocitem" href="#Parameters/Init/Start"><span>Parameters/Init/Start</span></a></li><li><a class="tocitem" href="#Results-and-Plotting"><span>Results and Plotting</span></a></li><li><a class="tocitem" href="#PathPlanning"><span>PathPlanning</span></a></li></ul></li><li><a class="tocitem" href="Internal.html">Internal</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Functions.html">Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Functions.html">Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ModiaSim/Modia.jl/blob/main/docs/src/Functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="Instantiation"><a class="docs-heading-anchor" href="#Instantiation">Instantiation</a><a id="Instantiation-1"></a><a class="docs-heading-anchor-permalink" href="#Instantiation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Modia.@instantiateModel" href="#Modia.@instantiateModel"><code>Modia.@instantiateModel</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">modelInstance = @instantiateModel(model; FloatType = Float64, aliasReduction=true, unitless=false,
    evaluateParameters=false, saveCodeOnFile=&quot;&quot;, log=false, logModel=false, logDetails=false, logStateSelection=false,
    logCode=false,logExecution=logExecution, logCalculations=logCalculations, logTiming=false)</code></pre><p>Instantiates a model, i.e. performs structural and symbolic transformations and generates a function for calculation of derivatives suitable for simulation.</p><ul><li><code>model</code>: model (declarations and equations)</li><li><code>FloatType</code>: Variable type for floating point numbers, for example: Float64, Measurements{Float64}, StaticParticles{Float64,100}, Particles{Float64,2000}</li><li><code>aliasReduction</code>: Perform alias elimination and remove singularities</li><li><code>unitless</code>: Remove units (useful while debugging models and needed for MonteCarloMeasurements)</li><li><code>evaluateParameters</code>: Use evaluated parameters in the generated code.</li><li><code>saveCodeOnFile</code>: If non-empty string, save generated code in file with name <code>saveCodeOnFile</code>.</li><li><code>log</code>: Log the different phases of translation</li><li><code>logModel</code>: Log the variables and equations of the model</li><li><code>logDetails</code>: Log internal data during the different phases of translation</li><li><code>logStateSelection</code>: Log details during state selection</li><li><code>logCode</code>: Log the generated code</li><li><code>logExecution</code>: Log the execution of the generated code (useful for timing compilation)</li><li><code>logCalculations</code>: Log the calculations of the generated code (useful for finding unit bugs)</li><li><code>logTiming</code>: Log timing of different phases</li><li><code>return modelInstance prepared for simulation</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/ModiaLang.jl#L890-L912">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia.instantiateModel" href="#Modia.instantiateModel"><code>Modia.instantiateModel</code></a> — <span class="docstring-category">Function</span></header><section><div><p>See documentation of macro [<code>@instantiateModel</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/ModiaLang.jl#L922-L924">source</a></section></article><h2 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Modia.simulate!" href="#Modia.simulate!"><code>Modia.simulate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solution = simulate!(instantiatedModel [, algorithm];
          merge            = missing,  # change parameter/init/start values
          tolerance        = 1e-6,     # relative tolerance
          startTime        = 0.0,
          stopTime         = 0.0,      # stopTime &gt;= startTime required
          interval         = missing,  # = (stopTime-startTime)/500
          interp_points    = 0,
          dtmax            = missing,  # = 100*interval
          adaptive         = true,
          nlinearMinForDAE = 10,
          log              = false,
          logStates        = false,
          logEvents        = false,
          logProgress      = false,
          logTiming        = false,
          logParameters    = false,
          logEvaluatedParameters   = false,
          requiredFinalStates      = missing
          requiredFinalStates_rtol = 1e-3,
          requiredFinalStates_atol = 0.0,
          useRecursiveFactorizationUptoSize = 0)</code></pre><p>Simulate <code>instantiatedModel::SimulationModel</code> with <code>algorithm</code> (= <code>alg</code> of <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/">ODE Solvers of DifferentialEquations.jl</a> or <a href="https://diffeq.sciml.ai/stable/solvers/dae_solve/">DAE Solvers of DifferentialEquations.jl</a>).</p><p>If the <code>algorithm</code> argument is missing, <code>algorithm=Sundials.CVODE_BDF()</code> is used, provided instantiatedModel has <code>FloatType = Float64</code>. Otherwise, a default algorithm will be chosen from DifferentialEquations (for details see <a href="https://arxiv.org/pdf/1807.06430">https://arxiv.org/pdf/1807.06430</a>, Figure 3). The symbols <code>CVODE_BDF</code> and <code>IDA</code> are exported from Modia, so that <code>simulate!(instantiatedModel, CVODE_BDF(), ...)</code> and <code>simulate!(instantiatedModel, IDA(), ...)</code> can be used (instead of <code>import Sundials; simulate!(instantiatedModel, Sundials.xxx(), ...)</code>).</p><p>The simulation results are stored in <code>instantiatedModel</code> and can be plotted with <code>plot(instantiatedModel, ...)</code>. The result values can be retrieved with <code>getValues(..)</code> for Var(..) and <code>getValue(..)</code> for Par(..).  <code>showInfo(instantiatedModel)</code> prints information about the signals in the result. For more details, see sections <a href="Functions.html#Parameters/Init/Start">Parameters/Init/Start</a>, <a href="Functions.html#Results-and-Plotting">Results and Plotting</a>.</p><p>The return argument <code>solution</code> is the return argument from <code>DifferentialEquations.solve(..)</code> and therefore all post-processing functionality from <code>DifferentialEqautions.jl</code> can be used. Especially,</p><ul><li>solution.t[i] # time-instant at storage point i (solution.t[end] = stopTime)</li><li>solution.u[i] # states at storage point i</li></ul><p>A simulation run can be aborted with <code>&lt;CTRL&gt; C</code> (SIGINT), provided <code>using PyPlot</code> or <code>import PyPlot</code> was not called before (the signals in Python module matplotlib.pyplot intervene with Julias signals, see <a href="https://github.com/JuliaPy/PyPlot.jl/issues/305">PyPlot.jl issue 305</a>).</p><p><strong>Optional ArgumentsS</strong></p><ul><li><code>merge</code>: Define parameters and init/start values that shall be merged with the previous values          stored in <code>model</code>, before simulation is started. If, say, an init value <code>phi = Var(init=1.0)</code>          is defined in the model, a different init value can be provided with          <code>merge = Map(phi=2.0)</code>.</li><li><code>tolerance</code>: Relative tolerance.</li><li><code>startTime</code>: Start time. If value is without unit, it is assumed to have unit [s].</li><li><code>stopTime</code>: Stop time. If value is without unit, it is assumed to have unit [s].</li><li><code>interval</code>: Interval to store result. If <code>interval=missing</code>, it is internally selected as             (stopTime-startTime)/500.             If value is without unit, it is assumed to have unit [s].</li><li><code>interp_points</code>: If crossing functions defined, number of additional interpolation points             in one step.</li><li><code>dtmax</code>: Maximum step size. If <code>dtmax==missing</code>, it is internally set to <code>100*interval</code>.</li><li><code>adaptive</code>: = true, if the <code>algorithm</code> should use step-size control (if available).             = false, if the <code>algorithm</code> should use a fixed step-size of <code>interval</code> (if available).</li><li><code>nlinearMinForDAE</code>: If <code>algorithm</code> is a DAE integrator (e.g. <code>IDA()</code>) and the size of a linear equation system             is <code>&gt;= nlinearMinForDAE</code> and the iteration variables of this equation system are a subset of the             DAE state derivatives, then during continuous integration (but not at events, including             initialization) this equation system is not locally solved but is solved via the DAE integrator.             Typically, for large linear equation systems, simulation efficiency is considerably improved             in such a case.f</li><li><code>log</code>: = true, to log the simulation.</li><li><code>logStates</code>: = true, to log the states, its init/start values and its units.</li><li><code>logEvents</code>: = true, to log events.</li><li><code>logProgress</code> = true, to printout current simulation time every 5s.</li><li><code>logTiming</code>: = true, to log the timing with <code>instantiatedModel.timer</code> which is an instance              of <a href="https://github.com/KristofferC/TimerOutputs.jl">TimerOutputs</a>.TimerOutput.              A user function can include its timing via<br/>             <code>TimerOutputs.@timeit instantiatedModel.timer &quot;My Timing&quot; &lt;statement&gt;</code>.</li><li><code>logParameters</code>: = true, to log parameters and init/start values defined in model.</li><li><code>logEvaluatedParameters</code>: = true, to log the evaluated parameter and init/start values that                           are used for initialization and during simulation.</li><li><code>requiredFinalStates</code>: is not <code>missing</code>: Test with <code>@test</code> whether the ODE state vector at the             final time instant is in agreement to vector <code>requiredFinalStates</code> with respect             to tolerances <code>requiredFinalStates_rtol, requiredFinalStates_atol</code>. If this is not the case, print the             final state vector (so that it can be included with copy-and-paste in the simulate!(..) call).             If you checked that the result of the simulation is correct, use <code>requiredFinalStates = []</code> to get             a printout of the required final states and then copy it in your test.</li><li><code>requiredFinalStates_rtol</code>: Relative tolerance used for <code>requiredFinalStates</code>.</li><li><code>requiredFinalStates_atol</code>: Absolute tolerance used for <code>requiredFinalStates</code> (see atol in <code>?isapprox</code>)</li><li><code>useRecursiveFactorizationUptoSize</code>: = 0: Linear equation systems A*v=b are solved with              <code>RecursiveFactorization.jl</code> instead of the default <code>lu!(..)</code> and <code>ldiv!(..)</code>, if              <code>length(v) &lt;= useRecursiveFactorizationUptoSize</code>.              According to <code>RecursiveFactorization.jl</code> docu, it is faster as <code>lu!(..)</code> with OpenBLAS,              for <code>length(v) &lt;= 500</code> (typically, more as a factor of two).              Since there had been some cases where <code>lu!(..)!</code> was successful,              but <code>RecursiveFactorization.jl</code> failed due to a singular system, the default is to use <code>lu!(..)!</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Modia
@usingModiaPlot

# Define model
inputSignal(t) = sin(t)

FirstOrder = Model(
    T = 0.2,
    x = Var(init=0.3),
    equations = :[u = inputSignal(time/u&quot;s&quot;),
                  T * der(x) + x = u,
                  y = 2*x]
)

# Modify parameters and initial values of model
FirstOrder2 = FirstOrder | Map(T = 0.4, x = Var(init=0.6))

# Instantiate model
firstOrder = @instantiateModel(FirstOrder2, logCode=true)


# Simulate with automatically selected algorithm (Sundials.CVODE_BDF())
# and modified parameter and initial values
simulate!(firstOrder, stopTime = 1.0, merge = Map(T = 0.6, x = 0.9), logEvaluatedParameters=true)

# Plot variables &quot;x&quot;, &quot;u&quot; in diagram 1, &quot;der(x)&quot; in diagram 2, both diagrams in figure 3
plot(firstOrder, [(&quot;x&quot;,&quot;u&quot;), &quot;der(x)&quot;], figure=3)

# Retrieve &quot;time&quot; and &quot;u&quot; values:
usig = getPlotSignal(firstOrder, &quot;x&quot;)
       # usig.xsig      : time vector
       # usig.xsigLegend: legend for time vector
       # usig.ysig      : &quot;x&quot; vector
       # usig.ysigLegend: legend for &quot;x&quot; vector
       # usig.ysigType  : ModiaResult.Continuous or ModiaResult.Clocked

# Simulate with Runge-Kutta 5/4 with step-size control
simulate!(firstOrder, Tsit5(), stopTime = 1.0)

# Simulate with Runge-Kutta 4 with fixed step size
simulate!(firstOrder, RK4(), stopTime = 1.0, adaptive=false)

# Simulate with algorithm that switches between
# Verners Runge-Kutta 6/5 algorithm if non-stiff region and
# Rosenbrock 4 (= A-stable method) if stiff region with step-size control
simulate!(firstOrder, AutoVern6(Rodas4()), stopTime = 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/SimulateAndPlot.jl#L32-L181">source</a></section></article><h2 id="Linearization"><a class="docs-heading-anchor" href="#Linearization">Linearization</a><a id="Linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Linearization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Modia.linearize!" href="#Modia.linearize!"><code>Modia.linearize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(A, finalStates) = linearize!(instantiatedModel [, algorithm];
                              stopTime = 0.0,
                              analytic = false,
                              &lt;all other keyword arguments of simulate!&gt;)</code></pre><p>Simulate until <code>stopTime</code> and linearize <code>instantiatedModel</code> at <code>finalStates</code>. The names of the state vector can be inquired by <code>get_xNames(instantiatedModel)</code>.</p><p>By default, linearization is performed numerically with a central finite difference approximation using package <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff</a>. When setting <code>analytic = true</code>, linearization is preformed analytically with package <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff</a>, so is computed by symbolically differentiating the model. <code>ForwardDiff</code> might not be compatible with some floating point types, such as <code>Measurements</code> and Julia triggers an error that some overloaded operations are ambiguous. So <code>analytic=true</code> will not work in such cases.</p><p>Analytic linearization returns matrix <code>A</code> in full precision whereas numeric linearization returns <code>A</code> in reduced precision (if FloatType = Float64, analytic linearization results in about 15 correct digits and numeric linearization in about 10 correct digits in the result). You can improve this situation, by using a larger <code>FloatType</code> for <code>instantiatedModel</code>, in case this is critical (see example below).</p><p><strong>Output arguments</strong></p><ul><li><p><code>A::Matrix</code>: Matrix A of the linear ODE: <span>$\Delta \dot{x} = A*\Delta x$</span>.</p></li><li><p><code>finalStates::Vector</code>: Linearization point.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Modia
using DoubleFloats
using Measurements

FirstOrder = Model(
    T = 0.4 ± 0.04,
    x = Var(init = 0.9 ± 0.09),
    equations = :[u = inputSignal(time/u&quot;s&quot;),
                  T * der(x) + x = u]
)

firstOrder1 = @instantiateModel(FirstOrder, FloatType = Measurement{Float64})

# Standard precision
(A1, finalStates1) = linearize!(firstOrder1)

# Higher precision
firstOrder2 = SimulationModel{Measurement{Double64}}(firstOrder1)
(A2, finalStates2) = linearize!(firstOrder2)

# Show results with 15 digits (default print with Measurements shows 3 digits)
println(IOContext(stdout, :error_digits=&gt;15), &quot;A1 = &quot;, A1)
println(IOContext(stdout, :error_digits=&gt;15), &quot;A2 = &quot;, A2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/SimulateAndPlot.jl#L509-L567">source</a></section></article><h2 id="Parameters/Init/Start"><a class="docs-heading-anchor" href="#Parameters/Init/Start">Parameters/Init/Start</a><a id="Parameters/Init/Start-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters/Init/Start" title="Permalink"></a></h2><p>The following functions are provided to inquire values of <em>parameters</em> and of <em>init/start</em> values before and after <em>evaluation</em>:</p><table><tr><th style="text-align: left">Functions</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="Functions.html#Modia.hasParameter"><code>hasParameter</code></a></td><td style="text-align: left">Return true, if a parameter/init/start name is known</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia.getParameter"><code>getParameter</code></a></td><td style="text-align: left">Return value of a parameter/init/start name</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia.getEvaluatedParameter"><code>getEvaluatedParameter</code></a></td><td style="text-align: left">Return value of an evaluated parameter/init/start name</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia.getLastValue"><code>getLastValue</code></a></td><td style="text-align: left">Return last available value of a variable name</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia.showParameters"><code>showParameters</code></a></td><td style="text-align: left">Print the parameters and the init/start values</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia.showEvaluatedParameters"><code>showEvaluatedParameters</code></a></td><td style="text-align: left">Print the evaluated parameters and init/start values</td></tr></table><article class="docstring"><header><a class="docstring-binding" id="Modia.hasParameter" href="#Modia.hasParameter"><code>Modia.hasParameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hasParameter(instantiatedModel, name::AbstractString)</code></pre><p>Return true if parameter <code>name</code> (for example <code>name = &quot;a.b.c&quot;</code>) is defined in the instantiateModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/SimulateAndPlot.jl#L603-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia.getParameter" href="#Modia.getParameter"><code>Modia.getParameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getParameter(instantiatedModel, name::AbstractString)</code></pre><p>Return the value of parameter or init/start value <code>name</code> (for example <code>name = &quot;a.b.c&quot;</code>). If <code>name</code> is not known, <code>missing</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/SimulateAndPlot.jl#L617-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia.getEvaluatedParameter" href="#Modia.getEvaluatedParameter"><code>Modia.getEvaluatedParameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getEvaluatedParameter(instantiatedModel, name::AbstractString)</code></pre><p>Return the value of evaluated parameter or init/start value <code>name</code> (for example <code>name = &quot;a.b.c&quot;</code>). If <code>name</code> is not known, <code>missing</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/SimulateAndPlot.jl#L626-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia.getLastValue" href="#Modia.getLastValue"><code>Modia.getLastValue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getLastValue(model::SimulationModel, name::String; unit=true)</code></pre><p>Return the last stored value of variable <code>name</code> from <code>model</code>. If <code>unit=true</code> return the value with its unit, otherwise with stripped unit.</p><p>If <code>name</code> is not known or no result values yet available, an info message is printed and the function returns <code>nothing</code>.</p><p><code>name</code> can be a time-varying variable or a parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/CodeGeneration.jl#L648-L658">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia.showParameters" href="#Modia.showParameters"><code>Modia.showParameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">showParameters(instantiatedModel)</code></pre><p>Print the parameters and the init/start values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/SimulateAndPlot.jl#L635-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia.showEvaluatedParameters" href="#Modia.showEvaluatedParameters"><code>Modia.showEvaluatedParameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">showEvaluatedParameters(instantiatedModel)</code></pre><p>Print the evaluated parameters and the evaluated init/start values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/SimulateAndPlot.jl#L647-L651">source</a></section></article><h2 id="Results-and-Plotting"><a class="docs-heading-anchor" href="#Results-and-Plotting">Results and Plotting</a><a id="Results-and-Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Results-and-Plotting" title="Permalink"></a></h2><p>The simulation result of a model <code>instantiatedModel</code> are provided as a <em>signal table</em>,  see <a href="https://github.com/ModiaSim/SignalTables.jl">SignalTables.jl</a>.</p><p>Therefore, all <a href="https://modiasim.github.io/SignalTables.jl/stable/Functions/OverviewOfFunctions.html">signal table functions</a> can be used on a simulated model, for example:</p><pre><code class="nohighlight hljs">using Modia

FirstOrder = Model(
    T = 0.2u&quot;s&quot;,
    x = Var(init=0.3),
    equations = :[u = sin(time/u&quot;s&quot;)
                  T * der(x) + x = u
                  y = 2*x]
)
simulate!(firstOrder, stopTime=10)
showInfo(firstOrder)    # list info about the result
t = getValues(firstOrder, &quot;time&quot;)  
y = getValues(firstOrder, &quot;y&quot;)      # use any plot program: plot(t,y)

# Write result on file
writeSignalTable(&quot;firstOrder.json&quot;, firstOrder, indent=2, log=true) </code></pre><p>See the generated <a href="../resources/fileio/firstOrder.json">json-file</a>.</p><p>For plotting, a plot package must be installed, e.g.,</p><pre><code class="language-julia hljs">julia&gt; ]add SignalTablesInterface_PyPlot        # if plotting with PyPlot desired
        add SignalTablesInterface_GLMakie       # if plotting with GLMakie desired
        add SignalTablesInterface_WGLMakie      # if plotting with WGLMakie desired
        add SignalTablesInterface_CairoMakie    # if plotting with CairoMakie desired</code></pre><p>In a model, the desired plot package is defined with:</p><pre><code class="language-julia hljs">using Modia
usePlotPackage(&quot;PyPlot&quot;)    # or ENV[&quot;SignalTablesPlotPackage&quot;] = &quot;PyPlot&quot;</code></pre><p>A Modia variable <code>a.b.c</code> is identified by a String key <code>&quot;a.b.c&quot;</code>. The legends/labels of the plots are automatically constructed by the names and units of the variables. Example:</p><pre><code class="language-julia hljs">using Modia
@usingPlotPackage   # execute `using SignalTablesInterface_XXX`

instantiatedModel = @instantiateModel(...)
simulate!(instantiatedModel, ...)
plot(instantiatedModel,
     [ (&quot;phi&quot;, &quot;r&quot;)        (&quot;phi&quot;, &quot;phi2&quot;, &quot;w&quot;);
       (&quot;w&quot;, &quot;w2&quot;, &quot;phi2&quot;) &quot;w&quot;                ],
     heading=&quot;Matrix of plots&quot;)</code></pre><p>generates the following plot:</p><p><img src="../resources/images/matrix-of-plots.png" alt="Matrix-of-Plots"/></p><h2 id="PathPlanning"><a class="docs-heading-anchor" href="#PathPlanning">PathPlanning</a><a id="PathPlanning-1"></a><a class="docs-heading-anchor-permalink" href="#PathPlanning" title="Permalink"></a></h2><p>There are some pre-defined functions to define reference paths</p><article class="docstring"><header><a class="docstring-binding" id="Modia.PTP_path" href="#Modia.PTP_path"><code>Modia.PTP_path</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">path = PTP_path(names; positions, v_max, a_max, startTime=0.0)</code></pre><p>Generate a new path object to move as fast as possible from positions[i,:] to positions[i+1,:]. The <code>positions[i,:]</code> can be a set of translational positions in [m], that is absolute distances, and/or rotational positions in  [rad] that is angles. In robotics such a movement is called PTP (Point-To-Point). The signals are constructed in such a way that it is not possible to move faster, given the maximally allowed velocity <code>v_max[j]</code> and the maximally allowed acceleration <code>a_max[j]</code> for signal <code>names[j]</code> and have a velocity of zero at the given <code>positions</code>.</p><p>If there are two or more signals (that is length(names) &gt; 1) then the path is constructed such that all signals are in the same periods in the acceleration, constant velocity and deceleration phase. This means that only one of the signals is at its limits whereas the others are synchronized in such a way that the end point is reached at the same time instant.</p><p>For example, this means that the signals have a velocity of zero at positions[1,:], one of the signals is accelerated with its maximally allowed acceleration until one of the signals reaches its maximally allowed velocity. At a proper time instant, one of the signals is decelerated with the negative value of its maximally allowed acceleration, so that all signals reach positions[2,:] with velocity zero.</p><p>This element is useful to generate a reference signal for a controller which controls, e.g., a drive train, or to drive a flange according to a given acceleration.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Modia
@usingModiaPlot

const ptp_path = PTP_path([&quot;angle1&quot;, &quot;angle2&quot;, &quot;angle3&quot;],
                          positions = [0.0 2.0 3.0;  # angle1=0.0, angle2=2.0, angle3=3.0
                                       0.5 3.0 4.0;
                                       0.8 1.5 0.3;
                                       0.2 1.5 0.8],
                          startTime = 0.1,
                          v_max = 2*ones(3),
                          a_max = 3*ones(3))
angles = zeros(3)
getPosition!(ptp_path, 0.5, angles)   # angles = [0.12, 2.24, 3.24]
path = getPath(ptp_path)
plot(path, [&quot;angle1&quot;, &quot;angle2&quot;, &quot;angle3&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/PathPlanning.jl#L10-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia.pathEndTime" href="#Modia.pathEndTime"><code>Modia.pathEndTime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tend = pathEndTime(path)</code></pre><p>Given a <code>path::PTP_path</code> return the end time <code>Tend</code> of the path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/PathPlanning.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia.getPosition!" href="#Modia.getPosition!"><code>Modia.getPosition!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getPosition!(path, time, position)</code></pre><p>Given a <code>path::PTP_path</code> and a time instant <code>time</code>, return the actual position at time <code>time</code> in vector <code>position</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/PathPlanning.jl#L184-L189">source</a></section><section><div><pre><code class="nohighlight hljs">getPosition!(path, time, position, velocity, acceleration)</code></pre><p>Given a <code>path::PTP_path</code> and a time instant <code>time</code>, return the actual position, velocity and acceleration at time <code>time</code> in vectors <code>position, velocity, acceleration</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/PathPlanning.jl#L242-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia.getPosition" href="#Modia.getPosition"><code>Modia.getPosition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pos = getPosition(path, index, time)</code></pre><p>Given a <code>path::PTP_path</code>, the <code>index</code> of a signal, and a time instant <code>time</code>, return the actual position at time <code>time</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/PathPlanning.jl#L330-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia.getIndex" href="#Modia.getIndex"><code>Modia.getIndex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">index = getIndex(path, name)</code></pre><p>Return the index of <code>name</code> in <code>path</code> or trigger an error, if not present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/PathPlanning.jl#L343-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia.getPath" href="#Modia.getPath"><code>Modia.getPath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getPath(path;
        names=path.names, tend=1.1*path.Tend, ntime=101, onlyPositions=false)</code></pre><p>Given a <code>path::PTP_path</code>, return a SignalTables.SignalTable with the time series of the path over <code>time</code> up to <code>tend</code> for all <code>ntime</code> time points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia.jl/blob/22ffbc24fc763873fde344e4f4576458422bd6a4/src/PathPlanning.jl#L357-L363">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tutorial/Appendix.html">« Appendix A</a><a class="docs-footer-nextpage" href="Internal.html">Internal »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Tuesday 5 July 2022 12:31">Tuesday 5 July 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
