var documenterSearchIndex = {"docs":
[{"location":"Internal.html#Internal","page":"Internal","title":"Internal","text":"","category":"section"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"This chapter documents internal functions that are typically only for use of the developers of package Modia.","category":"page"},{"location":"Internal.html#Code-Generation","page":"Internal","title":"Code Generation","text":"","category":"section"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"This section provides functions to generate Julia code of the transformed equations.","category":"page"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"CurrentModule = Modia","category":"page"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"SimulationModel\r\ngenerate_getDerivatives!\r\ninit!\r\noutputs!\r\naddToResult!\r\ngetFloatType\r\nbaseType\r\nmeasurementToString","category":"page"},{"location":"Internal.html#Modia.SimulationModel","page":"Internal","title":"Modia.SimulationModel","text":"simulationModel = SimulationModel{FloatType,TimeType}(\n        modelModule, modelName, getDerivatives!, equationInfo, x_startValues,\n        parameters, variableNames;\n        vSolvedWithInitValuesAndUnit::OrderedDict{String,Any}(),\n        vEliminated::Vector{Int}=Int[],\n        vProperty::Vector{Int}=Int[],\n        var_name::Function = v->nothing)\n\nArguments\n\nmodelModule: Module in which @instantiateModel is invoked (it is used for Core.eval(modelModule, ...)), that is evaluation of expressions in the environment of the user.\nmodelName::String: Name of the model\ngetDerivatives::Function: Function that is used to evaluate the model equations, typically generated with [Modia.generate_getDerivatives!].\nequationInfo::Modia.EquationInfo: Information about the states and the equations.\nx_startValues:: Deprecated (is no longer used).\nparameters: A hierarchical NamedTuple of (key, value) pairs defining the parameter and init/start values.\nvariableNames: A vector of variable names. A name can be a Symbol or a String.\n\n\n\n\n\n","category":"type"},{"location":"Internal.html#Modia.generate_getDerivatives!","page":"Internal","title":"Modia.generate_getDerivatives!","text":"code = generate_getDerivatives!(AST, equationInfo, parameters, variables, functionName;\n                                hasUnits=false)\n\nReturn the code of the getDerivatives! function as Expr using the Symbol functionName as function name. By eval(code) or fc = @RuntimeGeneratedFunction(code) the function is compiled and can afterwards be called.\n\nArguments\n\nAST::Vector{Expr}: Abstract Syntax Tree of the equations as vector of Expr.\nequationInfo::Modia.EquationInfo: Data structure returned by `Modia.getSortedAndSolvedAST           holding information about the states.\nparameters: Vector of parameter names (as vector of symbols)\nvariables: Vector of variable names (as vector of symbols). The first entry is expected to be time, so variables[1] = :time.\nfunctionName::Function: The name of the function that shall be generated.\n\nOptional Arguments\n\npre:Vector{Symbol}: pre-variable names\nhasUnits::Bool: = true, if variables have units. Note, the units of the state vector are defined in equationinfo.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.init!","page":"Internal","title":"Modia.init!","text":"success = init!(simulationModel)\n\nInitialize simulationModel::SimulationModel at startTime. In particular:\n\nEmpty result data structure.\nMerge parameter and init/start values into simulationModel.\nConstruct x_start.\nCall simulationModel.getDerivatives! once with isInitial(simulationModel) = true to compute and store all variables in the result data structure at startTime and initialize simulationModel.linearEquations.\nCheck whether explicitly solved variables that have init-values defined, have the required value after initialization (-> otherwise error).\n\nIf initialization is successful return true, otherwise false.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.outputs!","page":"Internal","title":"Modia.outputs!","text":"outputs!(x, t, integrator)\n\nDifferentialEquations FunctionCallingCallback function for SimulationModel that is used to store results at communication points.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.addToResult!","page":"Internal","title":"Modia.addToResult!","text":"addToResult!(simulationModel, der_x, variableValues...)\n\nAdd variableValues... to simulationModel::SimulationModel. It is assumed that the first variable in variableValues is time.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.getFloatType","page":"Internal","title":"Modia.getFloatType","text":"floatType = getFloatType(simulationModel::SimulationModel)\n\nReturn the floating point type with which simulationModel is parameterized (for example returns: Float64, Float32, DoubleFloat, Measurements.Measurement{Float64}).\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.baseType","page":"Internal","title":"Modia.baseType","text":"baseType(T)\n\nReturn the base type of a type T.\n\nExamples\n\nbaseType(Float32)                # Float32\nbaseType(Measurement{Float64})   # Float64\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.measurementToString","page":"Internal","title":"Modia.measurementToString","text":"str = measurementToString(v)\n\nReturn variable v::Measurements.Measurement{FloatType} or a vector of such variables in form of a string will the full number of significant digits.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Inquiries-in-Model","page":"Internal","title":"Inquiries in Model","text":"","category":"section"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"isInitial\r\nisTerminal\r\nisEvent\r\nisFirstEventIteration\r\nisFirstEventIterationDirectlyAfterInitial\r\nisAfterSimulationStart\r\nisZeroCrossing\r\nstoreResults","category":"page"},{"location":"Internal.html#Modia.isInitial","page":"Internal","title":"Modia.isInitial","text":"isInitial(instantiatedModel)\n\nReturn true, if initialization phase of simulation.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.isTerminal","page":"Internal","title":"Modia.isTerminal","text":"isTerminal(instantiatedModel)\n\nReturn true, if terminal phase of simulation.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.isEvent","page":"Internal","title":"Modia.isEvent","text":"isEvent(instantiatedModel)\n\nReturn true, if event phase of simulation (including initialization).\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.isFirstEventIteration","page":"Internal","title":"Modia.isFirstEventIteration","text":"isFirstEventIteration(instantiatedModel)\n\nReturn true, if event phase of simulation (including initialization) and during the first iteration of the event iteration.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.isFirstEventIterationDirectlyAfterInitial","page":"Internal","title":"Modia.isFirstEventIterationDirectlyAfterInitial","text":"isFirstEventIterationDirectlyAfterInitial(instantiatedModel)\n\nReturn true, if first iteration directly after initialization where initial=true (so at the startTime of the simulation).\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.isAfterSimulationStart","page":"Internal","title":"Modia.isAfterSimulationStart","text":"isAfterSimulationStart(instantiatedModel)\n\nReturn true, if after start of simulation (returns false during initialization).\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.isZeroCrossing","page":"Internal","title":"Modia.isZeroCrossing","text":"isZeroCrossing(instantiatedModel)\n\nReturn true, if event indicators (zero crossings) shall be computed.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#Modia.storeResults","page":"Internal","title":"Modia.storeResults","text":"storeResults(instantiatedModel)\n\nReturn true, if results shall be stored.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/Simulation.html#Simulation","page":"3 Simulation","title":"3 Simulation","text":"","category":"section"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"A particular model is instantiated, simulated and results plotted with the commands:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"using Modia\r\n@usingModiaPlot\r\n\r\nfilter = @instantiateModel(Filter)\r\nsimulate!(filter, stopTime=10.0)\r\nplot(filter, \"y\", figure=1)","category":"page"},{"location":"tutorial/Simulation.html#.1-Instantiating","page":"3 Simulation","title":"3.1 Instantiating","text":"","category":"section"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"The @instantiateModel macro takes additional arguments:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"modelInstance = @instantiateModel(model; FloatType = Float64, aliasReduction=true, unitless=false,\r\n        evaluateParameters=false, log=false, logModel=false, logDetails=false, logStateSelection=false,\r\n        logCode=false,logExecution=logExecution, logCalculations=logCalculations, logTiming=false)","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"The macro performs structural and symbolic transformations, generates a function for calculation of derivatives suitable for use with DifferentialEquations.jl and returns SimulationModel that can be used in other functions, for example to simulate or plot results. Explanation of the arguments:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"model: model (declarations and equations)\nFloatType: Variable type for floating point numbers, for example: Float64, Measurements{Float64}, StaticParticles{Float64,100}, Particles{Float64,2000}\naliasReduction: Perform alias elimination and remove singularities\nunitless: Remove units (useful while debugging models and needed for MonteCarloMeasurements)\nevaluateParameters: Use evaluated parameters in the generated code.\nlog: Log the different phases of translation\nlogModel: Log the variables and equations of the model\nlogDetails: Log internal data during the different phases of translation\nlogStateSelection: Log details during state selection\nlogCode: Log the generated code\nlogExecution: Log the execution of the generated code (useful for timing compilation)\nlogCalculations: Log the calculations of the generated code (useful for finding unit bugs)\nlogTiming: Log timing of different phases\nreturn modelInstance prepared for simulation","category":"page"},{"location":"tutorial/Simulation.html#.2-Simulating","page":"3 Simulation","title":"3.2 Simulating","text":"","category":"section"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"The simulate! function performs one simulation with DifferentialEquations.jl using by default integrator Sundials.CVODE_BDF(), provided instantiatedModel has FloatType = Float64. Otherwise, a default algorithm will be chosen from DifferentialEquations (for details see https://arxiv.org/pdf/1807.06430, Figure 3). The reason to choose CVODE_BDF as default integrator is that it is a very robust integrator and also usually very efficient for larger models, provided there are no undamped vibrations. It is also possible to specify the integrator as second argument of simulate!:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"using Modia\r\n@usingModiaPlot\r\n\r\nfilter = @instantiateModel(Filter)\r\nsol = simulate!(filter, Tsit5(), stopTime=10.0, merge=Map(T=0.5, x=0.8))\r\nplot(filter, [\"y\", \"x\"], figure=1)","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"Integrator DifferentialEquations.Tsit5 is an adaptive Runge-Kutta method of order 5/4 from Tsitouras. There are > 100 ODE integrators provided. For details, see here.","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"Parameters and init/start values can be changed with the merge keyword. The effect is the same, as if the filter would have been instantiated with:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"filter = @instantiateModel(Filter | Map(T=0.5, x=Var(init=0.8))","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"Note, with the merge keyword in simulate!, init/start values are directly given as a value (x = 0.8) and are not defined with Var(..).","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"Function simulate! returns sol which is the value that is returned by function DifferentialEquations.solve. Functions of DifferentialEquations that operate on this return argument can therefore also be used on the return argument sol of simulate!.","category":"page"},{"location":"tutorial/Simulation.html#.4-Plotting","page":"3 Simulation","title":"3.4 Plotting","text":"","category":"section"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"A short overview of the most important plot commands is given in section Results and Plotting","category":"page"},{"location":"tutorial/Simulation.html#.5-State-selection-(DAEs)","page":"3 Simulation","title":"3.5 State selection (DAEs)","text":"","category":"section"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"Modia has a sophisticated symbolic engine to transform high index DAEs (Differential Algebraic Equations) automatically to ODEs (Ordinary Differential Equations in state space form). During the transformation, equations might be analytically differentiated and code might be generated to solve linear equation systems numerically during simulation. The current engine cannot transform a DAE to ODE form, if the DAE contains nonlinear algebraic equations. There is an (internal) prototype available to transform nearly any DAE system to a special index 1 DAE system that can be solved with standard DAE integrators. After a clean-up phase, this engine will be made publicly available at some time in the future. Some of the algorithms used in Modia are described in Otter and Elmqvist (2017). Some algorithms are not yet published.","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"Usually, the symbolic engine is only visible to the modeler, when the model has errors, or when the number of ODE states is less than the number of DAE states. The latter case is discussed in this section.","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"The following object diagram shows two rotational inertias that are connected by an ideal gear. One inertia is actuated with a sinusoidal torque:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"(Image: TwoInertiasAndIdealGear)","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"In order to most easily understand the issues, this model is provided in a compact, \"flattened\" form:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"TwoInertiasAndIdealGearTooManyInits = Model(\r\n    J1    = 50,\r\n    J2    = 100,\r\n    ratio = 2,\r\n    f     = 3, # Hz\r\n\r\n    phi1 = Var(init = 0.0), # Absolute angle of inertia1\r\n    w1   = Var(init = 0.0), # Absolute angular velocity of inertia1\r\n    phi2 = Var(init = 0.0), # Absolute angle of inertia2\r\n    w2   = Var(init = 0.0), # Absolute angular velocity of inertia2\r\n\r\n    equations = :[\r\n        tau = 2.0*sin(2*3.14*f*time/u\"s\")\r\n\r\n        # inertia1\r\n        w1 = der(phi1)\r\n        J1*der(w1) = tau - tau1\r\n\r\n        # ideal gear\r\n        phi1 = ratio*phi2\r\n        ratio*tau1 = tau2\r\n\r\n        # inertia2\r\n        w2 = der(phi2)\r\n        J2*der(w2) = tau2\r\n    ]\r\n)\r\n\r\ndrive1 = @instantiateModel(TwoInertiasAndIdealGearTooManyInits)\r\nsimulate!(drive1, Tsit5(), stopTime = 1.0, logStates=true)\r\nplot(drive1, [(\"phi1\", \"phi2\"), (\"w1\", \"w2\")])","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"The option logStates=true results in the following output:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"... Simulate model TwoInertiasAndIdealGearTooManyInits\r\n\r\n│ # │ state  │ init │ unit │ nominal │\r\n├───┼────────┼──────┼──────┼─────────┤\r\n│ 1 │ phi2   │ 0.0  │      │ NaN     │\r\n│ 2 │ w2     │ 0.0  │      │ NaN     │","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"This model translates and simulates without problems.","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"Changing the init-value of w2 to 1.0 and re-simulating:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"simulate!(drive1, Tsit5(), stopTime = 1.0, logStates=true, merge = Map(w2=1.0))","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"results in the following error:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"... Simulate model TwoInertiasAndIdealGearTooManyInits\r\n\r\n│ # │ state │ init │ unit │ nominal │\r\n├───┼───────┼──────┼──────┼─────────┤\r\n│ 1 │ phi2  │ 0.0  │      │ NaN     │\r\n│ 2 │ w2    │ 1.0  │      │ NaN     │\r\n\r\n\r\nError from simulate!:\r\nThe following variables are explicitly solved for, have init-values defined\r\nand after initialization the init-values are not respected\r\n(remove the init-values in the model or change them to start-values):\r\n\r\n│ # │ name │ beforeInit │ afterInit │\r\n├───┼──────┼────────────┼───────────┤\r\n│ 1 │ w1   │ 0.0        │ 2.0       │","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"The issue is the following:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"Every variable that is used in the der operator is a potential ODE state. When an init value is defined for such a variable, then Modia either utilizes this initial condition (so the variable has this value after initialization), or an error is triggered, as in the example above.","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"The model contains the equation:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"phi1 = ratio*phi2","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"So the potential ODE states phi1 and phi2 are constrained, and only one of them can be selected as ODE state, and the other variable is computed from this equation. Since parameter ratio can be changed before simulation is started, it can be changed also to a value of ratio = 0. Therefore, only when phi2 is selected as ODE state, phi1 can be uniquely computed from this equation. If phi1 would be selected as ODE state, then a division by zero would occur, if ratio = 0, since phi2 = phi1/ratio. For this reason, Modia selects phi2 as ODE state. This means the init value of phi1 has no effect. This is uncritical, as long as initialization computes this init value from the constraint equation above, as done in the example above.","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"When differentiating the equation above:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"der(phi1) = ratio*der(phi2)  # differentiated constraint equation\r\n       w1 = der(phi1)\r\n       w2 = der(phi2)","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"it becomes obvious, that there is also a hidden constraint equation for the potential ODE states w1, w2:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"w1 = ratio*w2  # hidden constraint equation","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"Again, Modia selects w2 as ODE state, and ignores the init value of w1. In the second simulation, the init value of w1 (= 0.0) is no longer consistent to the init value of w2 (= 1.0). Therefore, an error occurs.","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"The remedy is to remove the init values of phi1, w1 from the model:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"drive2 = @instantiateModel(TwoInertiasAndIdealGearTooManyInits |\r\n                                Map(phi1 = Var(init=nothing),\r\n                                    w1   = Var(init=nothing)) )\r\nsimulate!(drive2, Tsit5(), stopTime = 1.0, logStates=true, merge = Map(w2=1.0))","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"and simulation is successful!","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"Modia tries to respect init values during symbolic transformation. In cases as above, this is not possible and the reported issue occurs. In some cases, it might not be obvious, why Modia selects a particular variable as an ODE state. You can get more information by setting logStateSelection=true:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"drive1 = @instantiateModel(TwoInertiasAndIdealGearTooManyInits, logStateSelection=true)","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"This results in the following output in the REPL:","category":"page"},{"location":"tutorial/Simulation.html","page":"3 Simulation","title":"3 Simulation","text":"Instantiating model TwoInertiasAndIdealGearTooManyInits\r\n  in module: Main.Tutorial\r\n  in file: <..>\\Modia\\examples\\Tutorial.jl:196\r\n\r\n=== getSortedAndSolvedAST(...) started for TwoInertiasAndIdealGearTooManyInits.\r\n\r\n... Equation set 1.1 ..............................\r\nEquations:\r\n   1: tau = 2.0 * sin((2 * 3.14 * f * time) / u\"s\")\r\nUnknown variables:\r\n   1: tau\r\nOne equation in one unknown variable. Solve the equation:\r\nJulia code:\r\n    tau = 2.0 * sin((2 * 3.14 * _FloatType(_p[:f])::_FloatType * time) / u\"s\")\r\n\r\n... Equation set 2.1 ..............................\r\nEquations:\r\n   4: phi1 = ratio * phi2\r\nUnknown variables:\r\n   7: phi2\r\n   4: phi1\r\n1 equation(s) in 2 unknown variable(s). Tear the system of equations:\r\n    Unknowns with start or init values: phi2, phi1\r\n    Tearing  variables: phi2\r\n    All solved unknowns are dummy states.\r\nJulia code:\r\n    phi1 = _FloatType(_p[:ratio])::_FloatType * phi2\r\n\r\n... Equation set 2.2 ..............................\r\nEquations:\r\n   6: w2 = der(phi2)\r\n   8: der(phi1) = ratio * der(phi2)\r\n   2: w1 = der(phi1)\r\nUnknown variables:\r\n   9: w2\r\n  10: der(phi2)\r\n   3: der(phi1)\r\n   2: w1\r\n3 equation(s) in 4 unknown variable(s). Tear the system of equations:\r\n    Unknowns with start or init values: w2, w1\r\n    Tearing  variables: w2\r\n    All solved unknowns are dummy states.\r\nJulia code:\r\n    var\"der(phi2)\" = w2\r\n    var\"der(phi1)\" = _FloatType(_p[:ratio])::_FloatType * var\"der(phi2)\"\r\n    w1 = var\"der(phi1)\"\r\n\r\n... Equation set 2.3 ..............................\r\nEquations:\r\n   5: ratio * tau1 = tau2\r\n   7: J2 * der(w2) = tau2\r\n  10: der(w2) = der(der(phi2))\r\n  11: der(der(phi1)) = ratio * der(der(phi2))\r\n   9: der(w1) = der(der(phi1))\r\n   3: J1 * der(w1) = tau - tau1\r\nUnknown variables:\r\n   8: tau2\r\n  11: der(w2)\r\n  13: der(der(phi2))\r\n  12: der(der(phi1))\r\n   5: der(w1)\r\n   6: tau1\r\n6 equation(s) in 6 unknown variable(s). Tear the system of equations:\r\n    Tearing  variables: der(w2)\r\n    Residual equations:\r\n       7: J2 * der(w2) = tau2\r\n    All unknowns are solved.\r\nTeared equation system is linear. Solve system with hasConstantCoefficients = false.\r\ncode = quote\r\n    local var\"der(w2)\", var\"der(der(phi2))\", var\"der(der(phi1))\", var\"der(w1)\", tau1, tau2\r\n    _leq_mode = initLinearEquationsIteration!(_m, 1)\r\n     ModiaBase.TimerOutputs.@timeit _m.timer \"ModiaBase LinearEquationsIteration!\" while ModiaBase.LinearEquationsIteration!(_leq_mode, _m.isInitial, _m.solve_leq, _m.storeResult, _m.time, _m.timer)\r\n            var\"der(w2)\" = _leq_mode.x[1] * u\"s^-1\"\r\n            var\"der(der(phi2))\" = var\"der(w2)\"\r\n            var\"der(der(phi1))\" = _FloatType(_p[:ratio])::_FloatType * var\"der(der(phi2))\"\r\n            var\"der(w1)\" = var\"der(der(phi1))\"\r\n            tau1 = -((_FloatType(_p[:J1])::_FloatType * var\"der(w1)\" - tau))\r\n            tau2 = _FloatType(_p[:ratio])::_FloatType * tau1\r\n            ModiaBase.appendVariable!(_leq_mode.residuals, Modia.Unitful.ustrip.(tau2) .- Modia.Unitful.ustrip.(_FloatType(_p[:J2])::_FloatType * var\"der(w2)\"))\r\n        end\r\n    _leq_mode = nothing\r\nend\r\nSort equations (BLT on all equations under the assumption that the ODE states are known).\r\n\r\nInformation message from getSortedAndSolvedAST for model TwoInertiasAndIdealGearTooManyInits:\r\nThe following variables are iteration variables but have no start/init values defined.\r\nIf units are used in the model, start/init values with correct units should be defined\r\nto avoid unit errors during compilation.\r\nInvolved variables:\r\n    der(w2)\r\n\r\n\r\nWarning message from getSortedAndSolvedAST for model TwoInertiasAndIdealGearTooManyInits:\r\nThe following variables have an 'init' initialization and are explicitly solved for.\r\nTherefore, the 'init' values have no effect, but must exactly match the values,\r\ncomputed during initialization. Otherwise this gives a run-time error.\r\nIt is adviced to use 'start' initialization or remove initialization for these variables.\r\nInvolved variables:\r\n    phi1\r\n    w1","category":"page"},{"location":"tutorial/Modeling.html#Modeling","page":"2 Modeling","title":"2 Modeling","text":"","category":"section"},{"location":"tutorial/Modeling.html#.1-Equation-oriented-models","page":"2 Modeling","title":"2.1 Equation oriented models","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"A low pass filter block with input u and output y","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"beginaligned\r\nT cdot fracdxdt + x = u\r\n     y = x \r\nx(t_0) = 0\r\nendaligned","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"can be defined as:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"using Modia\r\n\r\nLowPassFilter = Model(\r\n    T = 0.2,\r\n    u = input,\r\n    y = output | Var(:x),\r\n    x = Var(init=0),\r\n    equations = :[T * der(x) + x = u],\r\n)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The symbols input and output refer to predefined variable constructors to define the input and output variables. If an equation has just a unique variable in the left hand side, y, the right hand side can be given as a quoted expression in a Var-constructor Var(:x) after the output constructor combined with the merge operator, |, see below.","category":"page"},{"location":"tutorial/Modeling.html#.2-Merging-models","page":"2 Modeling","title":"2.2 Merging models","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"It is possible to combine models by merging. If we want to change the model to become a highpass filter, an alternative output equation","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"y = -x + u","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"is defined in an anonymous model Model( y = :(-x + u) ). This anonymous model is merged with LowPassFilter using the merge operator |:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"HighPassFilter = LowPassFilter | Model( y = Var(:(-x + u) ) )","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The merging implies that the output property of y is kept, but the binding expression is changed from :x to :(-x + u).","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"In general, recursive merging is desired and Modia provides a mergeModels function for that (see appendix A.3 MergeModels algorithm). This function is invoked as a binary operator | (also used for merge in Python). Note, that the order of the arguments/operands are important.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Generalizing the block to have two outputs for both low and high pass filtering would be done as follows:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"LowAndHighPassFilter = LowPassFilter | Model(\r\n        y = nothing,\r\n        low = output | Var(:x),\r\n        high = output | Var(:(-x + u)),\r\n    )","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The equation for y is removed by \"assigning\" nothing and two variables are defined and declared as outputs.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Model LowAndHighPassFilter represents the following equations:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"beginaligned\r\nT cdot fracdxdt + x = u\r\n     low = x \r\n    high = -x + u \r\nx(t_0) = 0\r\nendaligned","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"By turning on logging of merging setLogMerge(true), the translator gives the log:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Adding: value = :(x)\r\nAdding: value = :(-x + u)\r\nDeleting: y\r\nAdding: low = Var(\r\n      output = true,\r\n      value = :(x),\r\n    ),\r\nAdding: high = Var(\r\n      output = true,\r\n      value = :(-x + u),\r\n    ),","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The resulting model is pretty printed by calling @showModel LowAndHighPassFilter:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"LowAndHighPassFilter = Model(\r\n  T = 0.2,\r\n  u = Var(\r\n    input = true,\r\n  ),\r\n  x = Var(\r\n    init = 0.0 V,\r\n  ),\r\n  equations = :([T * der(x) + x = u]),\r\n  low = Var(\r\n    output = true,\r\n    value = :(x),\r\n  ),\r\n  high = Var(\r\n    output = true,\r\n    value = :(-x + u),\r\n  ),\r\n),","category":"page"},{"location":"tutorial/Modeling.html#.3-Functions-and-tables","page":"2 Modeling","title":"2.3 Functions and tables","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"In order to test an input/output block as defined in the previous section, an input needs to be defined. This can be made by adding an equation for u. Assume we want u to be sinousoidial with an increasing frequency:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"TestLowAndHighPassFilter = LowAndHighPassFilter | Model(\r\n        u = :(sin( (time+1u\"s\")*u\"1/s/s\" * time)*u\"V\"),\r\n        x = Var(init=0.2u\"V\")\r\n    )","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"time is a reserved name for the independent variable. It has unit s for seconds. The Julia package Unitful provides a means for defining units and managing unit inference. It need not be explicitly defined, because its symbols are exported by using Modia. Definition of units is done with a string macro u\"...\". In this case, the input signal was given unit Volt. The state x must then also have consistent unit, that is Volt. If the model equations contain systems of simultaneous equations, then approximate guess values, optionally with units, must be given start: i = Var(start=0.0u\"A\").","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The input signal can also be defined by interpolation in a table:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"using Interpolations\r\n\r\ntable = CubicSplineInterpolation(0:0.5:2.0, [0.0, 0.7, 2.0, 1.8, 1.2])\r\nTestLowAndHighPassFilter2 = TestLowAndHighPassFilter | Map(u = :(table(time*u\"1/s\")*u\"V\"))","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"It is possible to call Julia functions that have more as one return argument:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"function ref(time)\r\n    y1 = sin(time)\r\n    y2 = cos(time)\r\n    return (y1,y2)\r\nend\r\n\r\nTestMultiReturningFunction1 = Model(\r\n    equations = :[\r\n        (y1,y2) = ref(time)\r\n        y3 = y1+y2\r\n    ]\r\n)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The returned arguments are typically numbers or arrays (see below). It is also possible to return an instance of a struct and, say, pass this instance as input to another function call.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"However, it is currently not supported that a function call modifies one of its arguments, or that a function call returns no argument at all:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"equations = :[\r\n    fc!(u,y)                   # Error: Not known that fc! computes y\r\n    println(\"This is a test\")  # Error: One equation is introduced but no unknown\r\n]","category":"page"},{"location":"tutorial/Modeling.html#.4-Hierarchical-modeling","page":"2 Modeling","title":"2.4 Hierarchical modeling","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"So far, the composition of models has resulted in dictionaries of key/value pairs with values being numeric values or quoted expressions. Hierarchical models are obtained if the values themselves are Models, i.e. dictionaries. A model with two filters can, for example, be defined as follows:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"TwoFilters = (\r\n    high = HighPassFilter,\r\n    low = LowPassFilter,\r\n)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Note, that the previous definitions of HighPassFilter and LowPassFilter was used instead of making the Model definitions inline.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"A band pass filter is a series connection of a high pass filter and a low pass filter and can be described as:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"BandPassFilter = (\r\n    u = input,\r\n    y = output,\r\n    high = HighPassFilter | Map(T=0.5, x=Var(init=0.1u\"V\")),\r\n    low = LowPassFilter | Map(x=Var(init=0.2u\"V\")),\r\n    equations = :[\r\n        high.u = u,\r\n        low.u = high.y,\r\n        y = low.y]\r\n)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"A new input, u, has been defined which is propagated to high.u. The series connection itself is obtained by the equation low.u = high.y. Note, that dot-notation is allowed in equations.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The input and output for the BandPassFilter when using the same input definition as for the TestLowPassFilter","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"TestBandPassFilter = BandPassFilter | Map(\r\n        u = :(sin( (time+1u\"s\")*u\"1/s/s\" * time)*u\"V\")\r\n    )\r\nbandPassFilter = @instantiateModel(TestBandPassFilter)\r\nsimulate!(bandPassFilter, Tsit5(), stopTime = 50u\"s\")\r\nplot(bandPassFilter, [\"u\", \"y\"], figure=2)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"is shown below:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"(Image: Band Pass Filter Plot)","category":"page"},{"location":"tutorial/Modeling.html#.5-Physically-oriented-modeling","page":"2 Modeling","title":"2.5 Physically oriented modeling","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"So far, only signal flow modeling has been used, i.e. input/output blocks coupled with equations between outputs and inputs. For object oriented modeling more high level constructs are necessary. Coupling is then acausal and involves potentials such as electric potential, positions, pressure, etc. and flows such as electric current, forces and torques and mass flow rate.","category":"page"},{"location":"tutorial/Modeling.html#.5.1-Connectors","page":"2 Modeling","title":"2.5.1 Connectors","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Models which contain any flow variable, i.e. a variable having an attribute flow=true, are considered connectors. Connectors must have equal number of flow and potential variables, i.e. variables having an attribute potential=true, and have matching array sizes. Connectors may not have any equations. An example of an electrical connector with potential (in Volt) and current (in Ampere) is shown below.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Pin = Model( v = potential, i = flow )","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The value potential is a shortcut for Var(potential=true) and similarly for flow.","category":"page"},{"location":"tutorial/Modeling.html#.5.2-Components","page":"2 Modeling","title":"2.5.2 Components","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Components are declared in a similar ways as blocks. However, the interfaces between components are defined using connector instances.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"An electrical resistor can be described as follows:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Resistor = Model(\r\n    R = 1.0u\"Ω\",\r\n    p = Pin,\r\n    n = Pin,\r\n    equations = :[\r\n        0 = p.i + n.i\r\n        v = p.v - n.v\r\n        i = p.i\r\n        R*i = v ]\r\n    )","category":"page"},{"location":"tutorial/Modeling.html#.5.3-Inheritance","page":"2 Modeling","title":"2.5.3 Inheritance","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Various physical components sometimes share common properties. One mechanism to handle this is to use inheritance. In Modia, merging is used.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Electrical components such as resistors, capacitors and inductors are categorized as oneports which have two pins. Common properties are: constraint on currents at the pins and definitions of voltage over the component and current through the component.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"OnePort = Model(\r\n    p = Pin,\r\n    n = Pin,\r\n    equations = :[\r\n        0 = p.i + n.i\r\n        v = p.v - n.v\r\n        i = p.i ] )","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Having such a OnePort definition makes it convenient to define electrical component models by merging OnePort with specific parameter definitions with default values and equations:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Resistor = OnePort | Model( R = 1.0u\"Ω\", equations = :[ R*i = v ], )\r\n\r\nCapacitor = OnePort | Model( C = 1.0u\"F\", v=Map(init=0.0u\"V\"), equations = :[ C*der(v) = i ] )\r\n\r\nInductor = OnePort | Model( L = 1.0u\"H\", i=Map(init=0.0u\"A\"), equations = :[ L*der(i) = v ] )\r\n\r\nConstantVoltage = OnePort | Model( V = 1.0u\"V\", equations = :[ v = V ] )","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The merged Resistor is shown below:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Resistor = Model(\r\n  p = Model(\r\n    v = Var(potential = true),\r\n    i = Var(flow = true),\r\n  ),\r\n  n = Model(\r\n    v = Var(potential = true),\r\n    i = Var(flow = true),\r\n  ),\r\n  equations = :([v = p.v - n.v; 0 = p.i + n.i; i = p.i, R * i = v]),\r\n  R = 1.0 Ω,\r\n),","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Note, there is a special merge-rule that the vectors of keys equations are appended.","category":"page"},{"location":"tutorial/Modeling.html#.5.4-Connections","page":"2 Modeling","title":"2.5.4 Connections","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Connections are described as an array of tuples listing the connectors that are connected:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"    ( <connect reference 1>, <connect reference 2>, ... )","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"A connect reference has either the form 'connect instance name' or 'component instance name'.'connect instance name' with 'connect instance name' being either a connector instance, input or output variable.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Examples","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"    connect = :[\r\n      (V.p, R1.p)\r\n      (R1.n, p)\r\n      (C1.n, V.n, R2.p)\r\n      ...\r\n    ]","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"For connectors, all the potentials of the connectors in the same connect tuple are set equal and the sum of all incoming flows to the model are set equal to the sum of the flows into sub-components. A Modelica inspired form of connections, i.e. connect-equations, are also supported:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"    equations = :[\r\n      connect(V.p, R1.p)\r\n      connect(R1.n, p)\r\n      connect(C1.n, V.n, R2.p)\r\n      ...\r\n    ]","category":"page"},{"location":"tutorial/Modeling.html#.5.5-Connected-models","page":"2 Modeling","title":"2.5.5 Connected models","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Having the above electrical component models, enables defining a filter","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"(Image: Filter Circuit)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"by instantiating components, setting parameters and defining connections.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Filter = (\r\n    R = Resistor | Map(R=0.5u\"Ω\"),\r\n    C = Capacitor | Map(C=2.0u\"F\"),\r\n    V = ConstantVoltage | Map(V=10.0u\"V\"),\r\n    connect = :[\r\n      (V.p, R.p)\r\n      (R.n, C.p)\r\n      (C.n, V.n)\r\n    ]\r\n)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The connect tuples are translated to:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"  V.p.v = R.p.v\r\n  0 = V.p.i + R.p.i\r\n  R.n.v = C.p.v\r\n  0 = R.n.i + C.p.i\r\n  C.n.v = V.n.v\r\n  0 = C.n.i + V.n.i","category":"page"},{"location":"tutorial/Modeling.html#.5.6-Parameter-propagation","page":"2 Modeling","title":"2.5.6 Parameter propagation","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Hierarchical modification of parameters is powerful but sometimes a bit inconvenient. It is also possible to propagate parameters introduced on a high level down in the hierarchy. The following Filter model defines three parameters, r, c and v. The r parameter is used to set the resistance of the resistor R: Map(R=:r).","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Filter2 = Model(\r\n    r = 2.0u\"Ω\",\r\n    c = 1.0u\"F\",\r\n    v = 10u\"V\",\r\n    R = Resistor | Map(R=:r),\r\n    C = Capacitor | Map(C=:c),\r\n    V = ConstantVoltage | Map(V=:v),\r\n    connect = :[\r\n      (V.p, R.p)\r\n      (R.n, C.p)\r\n      (C.n, V.n)\r\n    ]\r\n)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Two separate filters can then be defined with:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"TwoFilters = Model( f1 = Filter | Map( r = 10.0, c = 2.0), f2 = Filter )","category":"page"},{"location":"tutorial/Modeling.html#.5.7-Re-declarations","page":"2 Modeling","title":"2.5.7 Re-declarations","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"It is possible to reuse a particular model topology by redeclaring the models of particular components. For example, changing the filter f1 to a voltage divider by changing C from a Capacitor to a Resistor. A predefined definition redeclare is used for this purpose.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"VoltageDividerAndFilter = TwoFilters | Map(f1 = Map(C = redeclare | Resistor | Map(R = 20.0)))","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"By using redeclare, a new model based on a Resistor is used for C and the usual merge semantics with the previously defined model of C is not used.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The above examples are available in file FilterCircuit.jl.","category":"page"},{"location":"tutorial/Modeling.html#.5.8-Drive-train-example","page":"2 Modeling","title":"2.5.8 Drive train example","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"A larger example that utilizes most of the previously described features of Modia is available as $(Modia.path)/examples/ServoSystem.jl. This is a textual (Modia) representation of a Modelica model","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"(Image: ServoSystem)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"and demonstrates how to build up a hierarchical, multi-domain model consisting of a servo-system with a load, where the servo-system consists of an electric motor with a current and speed controller, as well with a more detailed model of a gearbox.","category":"page"},{"location":"tutorial/Modeling.html#.6-Arrays","page":"2 Modeling","title":"2.6 Arrays","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Model parameters and variables can be arrays. For example a linear state space system","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"beginaligned\r\nfracdboldsymbolxdt = boldsymbolA cdot boldsymbolx + boldsymbolB cdot boldsymbolu\r\n            boldsymboly = boldsymbolC cdot boldsymbolx + boldsymbolD cdot boldsymbolu\r\nendaligned","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"can be defined as:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"StateSpace = Model(\r\n    A = fill(0.0, 0, 0),\r\n    B = fill(0.0, 0, 0),\r\n    C = fill(0.0, 0, 0),\r\n    D = fill(0.0, 0, 0),\r\n    u = input,\r\n    y = output,\r\n    x = Var(init = zeros(0)),\r\n    equations = :[\r\n        der(x) = A*x + B*u\r\n             y = C*x + D*u\r\n    ]\r\n)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"and used as:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"SecondOrder = Model(\r\n    w = 20.0,\r\n    D =  0.1,\r\n    k =  2.0,\r\n    sys = StateSpace | Map(A = :([  0        1;\r\n                                 -w^2  -2*D*w]),\r\n                           B = :([0; w^2;;]),    # Julia 1.7: Trailing \";;\" defines a column matrix\r\n                           C = :([k 0]),\r\n                           D = :(zeros(1,1)),\r\n                           x = Var(init = zeros(2)) ),\r\n    equations = :[sys.u = [1.0]]\r\n)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Variables sys.u and sys.y are vectors with one element each.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Note, [0; w^2] is a vector in Julia and not a column matrix. In order that B is defined as column matrix, the Julia 1.7 feature is used to append two semikolons, that is, [0; w^2;;]","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Array equations remain array equations during symbolic transformation and in the generated code, so the code is both compact and efficient. In order that this is reasonably possible, the definition of an array cannot be split in different statements:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"equations = :[             # error, vector v is not defined as one symbol\r\n    m1*der(v[1]) = 2.0\r\n    m2*der(v[2]) = 3.0\r\n]","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"If scalar equations are needed in which arrays are used, then the arrays have to be first defined and then elements can be used.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"v = Var(init=zeros(2)),\r\nequations = :[\r\n    a = der(v)\r\n    a1 = a[1]\r\n    a2 = a[2]\r\n    m1*a1 = 2.0\r\n    m2*a2 = 3.0\r\n]","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"When the init or start value of an array variable is defined as a StaticArrays array, then the value of this array remains to be a StaticArrays variable also in the generated code. The benefit is that array operations are more efficient:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"using StaticArrays\r\nTestArray1 = Model\r\n    v = Var(init=SVector{3,Float64}(1.0, 2.0, 3.0)),\r\n    equations = :[der(v) = -v]\r\n)\r\ntestArray1 =  @instantiateModel(TestArray1, logCode=true)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Note, the generated code is shown in the REPL if logCode=true is defined:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"function getDerivatives(_x, _m::Modia.SimulationModel{_FloatType,_TimeType} ...\r\n    ...\r\n    v::ModiaBase.SVector{3,_FloatType} = ModiaBase.SVector{3,_FloatType}(_x[1:3])\r\n    var\"der(v)\" = -v\r\n    ...","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The sizes of StaticArrays variables cannot be changed, after @instantiatedModel was called. However, the sizes of standard array variables can be changed with keyword argument merge in simulate! (so no re-generation and re-compilation of the code is needed):","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"TestArray2 = Model(\r\n    v = Var(init=[1.0, 2.0, 3.0]),   # length(v) = 3\r\n    equations = :[der(v) = -v]\r\n)\r\ntestArray2 = @instantiateModel(TestArray2)\r\nsimulate!(testArray2, stopTime=2.0, merge=Map(v = [4.0, 3.0, 2.0, 1.0]))   # length(v) = 4\r\nplot(testArray2, \"v\", figure=5)","category":"page"},{"location":"tutorial/Modeling.html#.7-Model-libraries","page":"2 Modeling","title":"2.7 Model libraries","text":"","category":"section"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"Modia provides a small set of pre-defined model components in directory Modia.modelsPath:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"AllModels.jl - Include all model libraries\nBlocks.jl - Input/output control blocks\nElectric.jl - Electric component models\nHeatTransfer.jl - 1D heat transfer component models\nRotational.jl - 1D rotational, mechanical component models\nTranslational.jl - 1D translational, mechanical component models\nPathPlanning - Defining reference trajectories and access them.","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"The desired libraries must be explicitly included with the help of utility path variable Modia.modelsPath. For example, the circuit of section 2.5.5 Connected models is constructed with these libraries in the following way:","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"using Modia\r\n@usingModiaPlot\r\n\r\ninclude(\"$(Modia.modelsPath)/Electric.jl\")\r\n\r\nFilterCircuit = Model(\r\n    R = Modia.Resistor  | Map(R=0.5u\"Ω\"),\r\n    C = Modia.Capacitor | Map(C=2.0u\"F\", v=Var(init=0.1u\"V\")),\r\n    V = Modia.ConstantVoltage | Map(V=10.0u\"V\"),\r\n    ground = Modia.Ground,\r\n    connect = :[\r\n      (V.p, R.p)\r\n      (R.n, C.p)\r\n      (C.n, V.n, ground.p)\r\n    ]\r\n)\r\n\r\nfilterCircuit = @instantiateModel(FilterCircuit)\r\nsimulate!(filterCircuit, Tsit5(), stopTime=10.0)\r\nplot(filterCircuit, [\"C.v\", \"C.i\"], figure=3)","category":"page"},{"location":"tutorial/Modeling.html","page":"2 Modeling","title":"2 Modeling","text":"It is planned to support a much larger set of predefined model components in the future.","category":"page"},{"location":"tutorial/Appendix.html#Appendix-A","page":"Appendix A","title":"Appendix A","text":"","category":"section"},{"location":"tutorial/Appendix.html#A.1-Var-constructor","page":"Appendix A","title":"A.1 Var constructor","text":"","category":"section"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"The constructor Var(..) defines attributes of a variable with key/value pairs. In column 1 the keys are shown. The default is that none of the keys are defined (meaning key = nothing). Most of the keys are also provided as predefined constants as shown in column 2 and 3. These constants can be used as shortcuts:","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"Var key ShortCut Shortcut value Description\nparameter parameter Var(parameter = true) If true, value is fixed during simulation\ninput input Var(input = true) If true, input signal\noutput output Var(output = true) If true, output signal\npotential potential Var(potential = true) If true, potential variable\nflow flow Var(flow = true) If true, flow variable\ninit – – Initial value of ODE state (defines unit and size)\nstart – – Start value of variable (defines unit and size)\nhideResult – – If true, the variable is not stored in the result","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"Example:","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"v = output | Var(start = zeros(3)u\"N*m\")\r\n\r\n# Same as: v = Var(output = true, start = zeros(3)u\"N*m\")","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"An attribute can be removed by using a value of nothing. Example:","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"System1 = Model(v = input | Var(init = 1.0), ...)\r\n\r\n# System2 = Model(v = input, ...)\r\nSystem2 = System1 | Map(v = Var(init = nothing), ...)","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"The following attributes are also defined for constructor Var, but have no effect yet. Using min, max, info already now, might be useful for model libraries:","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"Var Key Shortcut Shortcut value Description\nconstant constant Var(constant = true) If true, value cannot be changed\nmin, max interval(a,b) Var(min = a, max = b) Allowed variable value range\ninfo info\"...\" Var(info=\"...\") Description","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"Example:","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"v = output | interval(0.0,1.0) | Var(start = zeros(3)u\"N*m\") | info\"An output variable\"\r\n\r\n# Same as: v = Var(output = true, min = 0.0, max = 1.0,\r\n#                  start = zeros(3)u\"N*m\", info = \"An output variable\")","category":"page"},{"location":"tutorial/Appendix.html#A.2-Dictionaries-and-quoted-expressions","page":"Appendix A","title":"A.2 Dictionaries and quoted expressions","text":"","category":"section"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"The fundamental mechanism for defining models, variables and parameter modifications in Modia are ordered dictionaries, i.e. a list of key/value pairs:","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"julia> using OrderedCollections\r\n\r\njulia> S = OrderedDict(:p=>5, :q=>10)\r\nOrderedDict{Symbol, Int64} with 2 entries:\r\n  :p => 5\r\n  :q => 10","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"It is also possible to define a constructor Model with keyword arguments which creates the ordered dictionary:","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"julia> Model(; kwargs...) = OrderedDict{Symbol, Any}(kwargs)\r\nModel (generic function with 1 method)\r\n\r\njulia> T=Model(q=100, r=200)\r\nOrderedDict{Symbol, Any} with 2 entries:\r\n  :q => 100\r\n  :r => 200","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"The values can also be a quoted expression, i.e. an expression enclosed in :( ), an array of quoted expressions enclosed in :[ ] or just a quoted symbol, :x. This mechanism is used to encode equations and expressions of the model which needs to be manipulated before the model can be simulated.","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"Julia defines a very useful merge operation between dictionaries:","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"julia> merge(S, T)\r\nOrderedDict{Symbol, Any} with 3 entries:\r\n  :p => 5\r\n  :q => 100\r\n  :r => 200","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"If a key already exists in the first dictionary (like :q), its value is overwritten (like :r) otherwise it's added (like :p). Such a merge semantic allows for unification of parameter modifications and inheritance as will be demonstrated below.","category":"page"},{"location":"tutorial/Appendix.html#A.3-MergeModels-algorithm","page":"Appendix A","title":"A.3 MergeModels algorithm","text":"","category":"section"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"The basics of the mergeModels algorithm and the merge operator | are defined as follows (without logging):","category":"page"},{"location":"tutorial/Appendix.html","page":"Appendix A","title":"Appendix A","text":"function mergeModels(m1::AbstractDict, m2::AbstractDict, env=Symbol())\r\n    result = deepcopy(m1)\r\n    for (k,v) in m2)\r\n        if typeof(v) <: AbstractDict\r\n            if k in keys(result) && ! (:_redeclare in keys(v))\r\n                if typeof(result[k]) <: AbstractDict\r\n                    result[k] = mergeModels(result[k], v, k)\r\n                end\r\n            else\r\n                result[k] = v\r\n            end\r\n        elseif v === nothing\r\n            delete!(result, k)\r\n        elseif k in keys(result) && k == :equations\r\n            equa = copy(result[k])\r\n            push!(equa.args, v.args...)\r\n            result[k] = equa\r\n        else\r\n            result[k] = v\r\n        end\r\n    end\r\n    return result\r\nend\r\n\r\n|(m::AbstractDict, n::AbstractDict) =  mergeModels(m, n)\r\n","category":"page"},{"location":"tutorial/FloatingPointTypes.html#Floating-Point-Types","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"","category":"section"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"The types of the floating point numbers in a Modia model can be parameterized with argument FloatType of macro @instantiateModel:","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"filter = @instantiateModel(Filter; FloatType = Float64)","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"By default, a floating point number has type Float64.","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"warning: Warning\nUsing another floating point type requires that a DifferentialEquations.jl integrator is used that is implemented in native Julia. An integrator that interfaces an integrator implemented in C (such as CVODE_BDF() the popular Sundials BDF method), cannot be used.","category":"page"},{"location":"tutorial/FloatingPointTypes.html#.1-Lower-and-higher-precision","page":"4 Floating Point Types","title":"4.1 Lower and higher precision","text":"","category":"section"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"In principal, any floating point type of Julia (so any type that is derived from AbstractFloat) can be used in the model and the integrators. Examples","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"Type Precision Package Usage\nFloat32 7 digits built-in Embedded system\nFloat64 16 digits built-in Offline simulation\nDouble64 30 digits DoubleFloats High precision needed\nBigFloat arbitrary built-in Very high precision needed (very slow)","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"The Float32 type might be used to test the execution and numerics of a model that shall later run on an embedded system target (there is no automatic way, yet, to translate a Modia model to C).","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"Double64 is a type that is constructed from two Float64 types. The execution is much faster as the comparable Julia built-in type BigFloat when set to 128 bit precision. The Double64 type might be used, when simulation with Float64 fails due to numerical reasons (for example the model is very sensitive, or equation systems are close to singularity) or when very stringent relative tolerances are needed, for example relative tolerance = 1e-15 as needed for some space applications.","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"In the following example, simulation is performed with a Float32 floating point type used for model and integrator and utilizing a Runge-Kutta integrator of order 4 with a fixed step size of 0.01 s:","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"filter = @instantiateModel(Filter, FloatType = Float32)\r\nsimulate!(filter, RK4(), adaptive=false, stopTime=10.0, interval=0.01)","category":"page"},{"location":"tutorial/FloatingPointTypes.html#.2-Uncertainties","page":"4 Floating Point Types","title":"4.2 Uncertainties","text":"","category":"section"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"Package Measurements provides a floating point type designed for error propagation. A floating point number is defined with a nominal value and an uncertainty:","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"using Measurements\r\n\r\nm1 = 2.1 ± 0.4\r\nm2 = 2*m1           # 4.2 ± 0.8\r\nm3 = m2 - m1        # 2.1 ± 0.4","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"The statement m1 = 2.1 ± 0.4 defines that m1 has a nominal value of 2.1 with a standard deviation of 0.4. This means that the probability is about 95 % that the value of m1 is in the range 1.3 .. 2.9. Package Measurements computes the error propagation with first-order theory (so this is typically an approximation) by computing the partial derivatives of all variables with respect to all source error definitions and computing the propagated error with this information. The benefit is that the error bounds are typically reasonably propagated and the computation is reasonably fast. The drawback is that it is an approximation and will be not correct, if the uncertainty is too large and/or the signals change too quickly (for example are discontinuous).","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"The following model defines a simple pendulum where a mass point is attached via a rod and a revolute joint to the environment. It is described by the equations","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"beginaligned\r\n     fracdvarphidt = omega \r\n     0 = m cdot L^2 cdot fracdomegadt + d cdot omega + m cdot g cdot L cdot sin(varphi)\r\nendaligned","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"where varphi is the rotation angle, omega the angular velocity, m the mass, L the rod length, d a damping constant and g the gravity constant. This model can be defined with the commands:","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"Pendulum = Model(\r\n   L = (0.8±0.1)u\"m\",\r\n   m = (1.0±0.1)u\"kg\",\r\n   d = (0.5±0.05)u\"N*m*s/rad\",\r\n   g = 9.81u\"m/s^2\",\r\n   phi = Var(init = (pi/2±0.1)*u\"rad\"),\r\n   w   = Var(init = 0u\"rad/s\"),\r\n   equations = :[\r\n          w = der(phi)\r\n        0.0 = m*L^2*der(w) + d*w + m*g*L*sin(phi)\r\n   ]\r\n)\r\n\r\npendulum = @instantiateModel(Pendulum, FloatType=Measurements.Measurement{Float64})\r\nsimulate!(pendulum, Tsit5(), stopTime = 10.0)\r\nplot(pendulum, \"phi\")","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"and simulates the pendulum with uncertain parameter and init values and results in the following plot:","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"(Image: PendulumWithUncertaintities)","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"The area around the nominal value of a variable characterizes the standard deviation.","category":"page"},{"location":"tutorial/FloatingPointTypes.html#.3-Monte-Carlo-Simulation","page":"4 Floating Point Types","title":"4.3 Monte-Carlo Simulation","text":"","category":"section"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"The Julia package MonteCarloMeasurements.jl provides calculations with particles. A value can be defined with a distribution of say 2000 values randomly chosen according to a desired distribution and then all calculations are performed with 2000 values at the same time (corresponds to 2000 simulations that are carried out).","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"In the example below, a modest form of 100 particles (100 simulations) with Uniform distributions of some parameters and init values are defined that correspond roughly to the definition with uncertainties of the previous section (but using uniform instead for normal distributions):","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"using Modia\r\nusing DifferentialEquations\r\nusing ModiaPlot\r\nusing MonteCarloMeasurements\r\nusing Distributions\r\nusing Unitful\r\n\r\nconst nparticles = 100\r\nuniform(vmin,vmax) = StaticParticles(nparticles,Distributions.Uniform(vmin,vmax))\r\n\r\nPendulum = Model(\r\n   L = uniform(0.6, 1.0),\r\n   m = uniform(0.8, 1.2),\r\n   d = uniform(0.4, 0.6),\r\n   g = 9.81,\r\n   phi = Var(init = uniform(pi/2-0.2, pi/2+0.2)),\r\n   w   = Var(init = 0),\r\n   equations = :[\r\n          w = der(phi)\r\n        0.0 = m*L^2*der(w) + d*w + m*g*L*sin(phi)\r\n   ]\r\n)\r\n\r\npendulum = @instantiateModel(Pendulum,FloatType=StaticParticles{Float64,nparticles})\r\nsimulate!(pendulum, Tsit5(), stopTime = 10.0)\r\nplot(pendulum, \"phi\", MonteCarloAsArea=false)","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"The simulation result is shown in the next figure:","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"(Image: PendulumWithMonteCarlo.png)","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"Since plot option MonteCarloAsArea=false is used, all 100 simulations are shown in the plot, together with the mean value of all simulations. The default plot behavior is to show the mean value and the area in which all simulations are contained (this is useful, if there are much more simulations, because GLMakie crashes when there are too many curves in a diagram).","category":"page"},{"location":"tutorial/FloatingPointTypes.html","page":"4 Floating Point Types","title":"4 Floating Point Types","text":"There are currently a few restrictions, in particular units are not yet supported in the combination of Modia and MonteCarloMeasurements, so units are not defined in the model above.","category":"page"},{"location":"tutorial/GettingStarted.html#Getting-Started","page":"1 Getting Started","title":"1 Getting Started","text":"","category":"section"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"A simple differential equation with x(t) in R","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"T cdot fracdxdt + x = 1  x(t_0) = 02","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"can be defined, simulated and plotted with the following commands:","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"using Modia       # reexports exported symbols from\r\n                  # DifferentialEquations and from Unitful\r\n@usingModiaPlot   # Use plot package defined with\r\n                  # ENV[\"MODIA_PLOT\"] or usePlotPackage(..)\r\n\r\n\r\n# Define model\r\nSimpleModel = Model(\r\n    T = 0.4,\r\n    x = Var(init=0.2),\r\n    equations = :[T * der(x) + x = 1],\r\n)\r\n\r\n# Transform to ODE form\r\nsimpleModel = @instantiateModel(SimpleModel)\r\n\r\n# Simulate with default integrator Sundials.CVODE_BDF\r\nsimulate!(simpleModel, stopTime = 1.2)\r\n\r\n# Simulate with a specific integrator (Tsit5) and use a unit for stopTime\r\nsimulate!(simpleModel, Tsit5(), stopTime = 1.2u\"s\")\r\n\r\n# Produce a line plot\r\nplot(simpleModel, (\"x\", \"der(x)\"))","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"A model is defined with a constructor Model taking a comma separated list of name/value pairs. The model consists of a definition of a parameter T with default value 0.2. Constructor Var with an init key is used to define the initial condition 0.2 of the state x, and one equation. Equations can have a Julia expression on both sides of the equal sign and are given as a quoted array expression :[ ] assigned to key equations.","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"The macro @instantiateModel(..) symbolically processes the model, in particular solves the equation for the derivative der(x), so the following equation will be used by the integrator:","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"fracdxdt = (1 - x)  T","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"Furthermore, a Julia function is generated and compiled to evaluate this equation. @instantiateModel(..) returns an instance containing all the information needed for the next steps.","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"The first simulate! function performs one simulation with the Modia default integrator Sundials.CVODE_BDF(). The second simulate! call defines the integrator as second argument. Integrator Tsit5 is an adaptive Runge-Kutta method of order 5/4 from Tsitouras. There are > 100 ODE integrators provided. For details, see here. The simulation result is stored inside simpleModel.","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"Function call plot(..) produces a line plot. Variables to be plotted are defined as tuples or arrays of variable names. Tuples are displayed in one diagram. A Vector or matrix of tuples or strings are displayed as vector or matrix of diagrams. When ENV[\"MODIA_PLOT\"] = \"GLMakie\" is set, then command plot(..) produces the following image","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"(Image: SimpleModel Plot)","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"When ENV[\"MODIA_PLOT\"] = \"PyPlot\" is set, the following image is produced:","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"(Image: SimpleModel Plot)","category":"page"},{"location":"tutorial/GettingStarted.html","page":"1 Getting Started","title":"1 Getting Started","text":"Note, the tool bar of PyPlot provides various interactive commands, for example to zoom into the plot or to store the plot in different formats on file (for example in png or svg format).","category":"page"},{"location":"Functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"CurrentModule = Modia","category":"page"},{"location":"Functions.html#Instantiation","page":"Functions","title":"Instantiation","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"@instantiateModel\r\ninstantiateModel","category":"page"},{"location":"Functions.html#Modia.@instantiateModel","page":"Functions","title":"Modia.@instantiateModel","text":"modelInstance = @instantiateModel(model; FloatType = Float64, aliasReduction=true, unitless=false,\n    evaluateParameters=false, log=false, logModel=false, logDetails=false, logStateSelection=false,\n    logCode=false,logExecution=logExecution, logCalculations=logCalculations, logTiming=false)\n\nInstantiates a model, i.e. performs structural and symbolic transformations and generates a function for calculation of derivatives suitable for simulation.\n\nmodel: model (declarations and equations)\nFloatType: Variable type for floating point numbers, for example: Float64, Measurements{Float64}, StaticParticles{Float64,100}, Particles{Float64,2000}\naliasReduction: Perform alias elimination and remove singularities\nunitless: Remove units (useful while debugging models and needed for MonteCarloMeasurements)\nevaluateParameters: Use evaluated parameters in the generated code.\nlog: Log the different phases of translation\nlogModel: Log the variables and equations of the model\nlogDetails: Log internal data during the different phases of translation\nlogStateSelection: Log details during state selection\nlogCode: Log the generated code\nlogExecution: Log the execution of the generated code (useful for timing compilation)\nlogCalculations: Log the calculations of the generated code (useful for finding unit bugs)\nlogTiming: Log timing of different phases\nreturn modelInstance prepared for simulation\n\n\n\n\n\n","category":"macro"},{"location":"Functions.html#Modia.instantiateModel","page":"Functions","title":"Modia.instantiateModel","text":"See documentation of macro [@instantiateModel]\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#Simulation","page":"Functions","title":"Simulation","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"simulate!","category":"page"},{"location":"Functions.html#Modia.simulate!","page":"Functions","title":"Modia.simulate!","text":"solution = simulate!(instantiatedModel [, algorithm];\n          merge            = missing,  # change parameter/init/start values\n          tolerance        = 1e-6,     # relative tolerance\n          startTime        = 0.0,\n          stopTime         = 0.0,      # stopTime >= startTime required\n          interval         = missing,  # = (stopTime-startTime)/500\n          interp_points    = 0,\n          dtmax            = missing,  # = 100*interval\n          adaptive         = true,\n          nlinearMinForDAE = 10,\n          log              = false,\n          logStates        = false,\n          logEvents        = false,\n          logProgress      = false,\n          logTiming        = false,\n          logParameters    = false,\n          logEvaluatedParameters   = false,\n          requiredFinalStates      = missing\n          requiredFinalStates_rtol = 1e-3,\n          requiredFinalStates_atol = 0.0,\n          useRecursiveFactorizationUptoSize = 0)\n\nSimulate instantiatedModel::SimulationModel with algorithm (= alg of ODE Solvers of DifferentialEquations.jl or DAE Solvers of DifferentialEquations.jl).\n\nIf the algorithm argument is missing, algorithm=Sundials.CVODE_BDF() is used, provided instantiatedModel has FloatType = Float64. Otherwise, a default algorithm will be chosen from DifferentialEquations (for details see https://arxiv.org/pdf/1807.06430, Figure 3). The symbols CVODE_BDF and IDA are exported from Modia, so that simulate!(instantiatedModel, CVODE_BDF(), ...) and simulate!(instantiatedModel, IDA(), ...) can be used (instead of import Sundials; simulate!(instantiatedModel, Sundials.xxx(), ...)).\n\nThe simulation results are stored in instantiatedModel and can be plotted with  plot(instantiatedModel, ...) and the result values can be retrieved with rawSignal(..) or getPlotSignal(..). printResultInfo(instantiatedModel) prints information about the signals in the result file. For more details, see chapter Results and Plotting).\n\nThe (optional) return argument solution is the return argument from DifferentialEquations.solve(..) and therefore all post-processing functionality from DifferentialEqautions.jl can be used. Especially,\n\nsolution.t[i] # time-instant at storage point i (solution.t[end] = stopTime)\nsolution.u[i] # states at storage point i\n\nA simulation run can be aborted with <CTRL> C (SIGINT).\n\nOptional Arguments\n\nmerge: Define parameters and init/start values that shall be merged with the previous values          stored in model, before simulation is started. If, say, an init value phi = Var(init=1.0)          is defined in the model, a different init value can be provided with          merge = Map(phi=2.0).\ntolerance: Relative tolerance.\nstartTime: Start time. If value is without unit, it is assumed to have unit [s].\nstopTime: Stop time. If value is without unit, it is assumed to have unit [s].\ninterval: Interval to store result. If interval=missing, it is internally selected as             (stopTime-startTime)/500.             If value is without unit, it is assumed to have unit [s].\ninterp_points: If crossing functions defined, number of additional interpolation points             in one step.\ndtmax: Maximum step size. If dtmax==missing, it is internally set to 100*interval.\nadaptive: = true, if the algorithm should use step-size control (if available).             = false, if the algorithm should use a fixed step-size of interval (if available).\nnlinearMinForDAE: If algorithm is a DAE integrator (e.g. IDA()) and the size of a linear equation system             is >= nlinearMinForDAE and the iteration variables of this equation system are a subset of the             DAE state derivatives, then during continuous integration (but not at events, including             initialization) this equation system is not locally solved but is solved via the DAE integrator.             Typically, for large linear equation systems, simulation efficiency is considerably improved             in such a case.f\nlog: = true, to log the simulation.\nlogStates: = true, to log the states, its init/start values and its units.\nlogEvents: = true, to log events.\nlogProgress = true, to printout current simulation time every 5s.\nlogTiming: = true, to log the timing with instantiatedModel.timer which is an instance              of TimerOutputs.TimerOutput.              A user function can include its timing via\n             TimerOutputs.@timeit instantiatedModel.timer \"My Timing\" <statement>.\nlogParameters: = true, to log parameters and init/start values defined in model.\nlogEvaluatedParameters: = true, to log the evaluated parameter and init/start values that                           are used for initialization and during simulation.\nrequiredFinalStates: is not missing: Test with @test whether the ODE state vector at the             final time instant is in agreement to vector requiredFinalStates with respect             to some relative tolerance requiredFinalStates_rtol. If this is not the case, print the             final state vector (so that it can be included with copy-and-paste in the simulate!(..) call).\nrequiredFinalStates_rtol: Relative tolerance used for requiredFinalStates.\nrequiredFinalStates_atol: Absolute tolerance used for requiredFinalStates (see atol in ?isapprox)\nuseRecursiveFactorizationUptoSize: = 0: Linear equation systems A*v=b are solved with              RecursiveFactorization.jl instead of the default lu!(..) and ldiv!(..), if              length(v) <= useRecursiveFactorizationUptoSize.              According to RecursiveFactorization.jl docu, it is faster as lu!(..) with OpenBLAS,              for length(v) <= 500 (typically, more as a factor of two).              Since there had been some cases where lu!(..)! was successful,              but RecursiveFactorization.jl failed due to a singular system, the default is to use lu!(..)!.\n\nExamples\n\nusing Modia\n@usingModiaPlot\n\n# Define model\ninputSignal(t) = sin(t)\n\nFirstOrder = Model(\n    T = 0.2,\n    x = Var(init=0.3),\n    equations = :[u = inputSignal(time/u\"s\"),\n                  T * der(x) + x = u,\n                  y = 2*x]\n)\n\n# Modify parameters and initial values of model\nFirstOrder2 = FirstOrder | Map(T = 0.4, x = Var(init=0.6))\n\n# Instantiate model\nfirstOrder = @instantiateModel(FirstOrder2, logCode=true)\n\n\n# Simulate with automatically selected algorithm (Sundials.CVODE_BDF())\n# and modified parameter and initial values\nsimulate!(firstOrder, stopTime = 1.0, merge = Map(T = 0.6, x = 0.9), logEvaluatedParameters=true)\n\n# Plot variables \"x\", \"u\" in diagram 1, \"der(x)\" in diagram 2, both diagrams in figure 3\nplot(firstOrder, [(\"x\",\"u\"), \"der(x)\"], figure=3)\n\n# Retrieve \"time\" and \"u\" values:\nusig = getPlotSignal(firstOrder, \"x\")\n       # usig.xsig      : time vector\n       # usig.xsigLegend: legend for time vector\n       # usig.ysig      : \"x\" vector\n       # usig.ysigLegend: legend for \"x\" vector\n       # usig.ysigType  : ModiaResult.Continuous or ModiaResult.Clocked\n\n# Simulate with Runge-Kutta 5/4 with step-size control\nsimulate!(firstOrder, Tsit5(), stopTime = 1.0)\n\n# Simulate with Runge-Kutta 4 with fixed step size\nsimulate!(firstOrder, RK4(), stopTime = 1.0, adaptive=false)\n\n# Simulate with algorithm that switches between\n# Verners Runge-Kutta 6/5 algorithm if non-stiff region and\n# Rosenbrock 4 (= A-stable method) if stiff region with step-size control\nsimulate!(firstOrder, AutoVern6(Rodas4()), stopTime = 1.0)\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#Linearization","page":"Functions","title":"Linearization","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"linearize!","category":"page"},{"location":"Functions.html#Modia.linearize!","page":"Functions","title":"Modia.linearize!","text":"(A, finalStates) = linearize!(instantiatedModel [, algorithm];\n                              stopTime = 0.0,\n                              analytic = false,\n                              <all other keyword arguments of simulate!>)\n\nSimulate until stopTime and linearize instantiatedModel at finalStates. The names of the state vector can be inquired by get_xNames(instantiatedModel).\n\nBy default, linearization is performed numerically with a central finite difference approximation using package FiniteDiff. When setting analytic = true, linearization is preformed analytically with package ForwardDiff, so is computed by symbolically differentiating the model. ForwardDiff might not be compatible with some floating point types, such as Measurements and Julia triggers an error that some overloaded operations are ambiguous. So analytic=true will not work in such cases.\n\nAnalytic linearization returns matrix A in full precision whereas numeric linearization returns A in reduced precision (if FloatType = Float64, analytic linearization results in about 15 correct digits and numeric linearization in about 10 correct digits in the result). You can improve this situation, by using a larger FloatType for instantiatedModel, in case this is critical (see example below).\n\nOutput arguments\n\nA::Matrix: Matrix A of the linear ODE: Delta dotx = A*Delta x.\nfinalStates::Vector: Linearization point.\n\nExample\n\nusing Modia\nusing DoubleFloats\nusing Measurements\n\nFirstOrder = Model(\n    T = 0.4 ± 0.04,\n    x = Var(init = 0.9 ± 0.09),\n    equations = :[u = inputSignal(time/u\"s\"),\n                  T * der(x) + x = u]\n)\n\nfirstOrder1 = @instantiateModel(FirstOrder, FloatType = Measurement{Float64})\n\n# Standard precision\n(A1, finalStates1) = linearize!(firstOrder1)\n\n# Higher precision\nfirstOrder2 = SimulationModel{Measurement{Double64}}(firstOrder1)\n(A2, finalStates2) = linearize!(firstOrder2)\n\n# Show results with 15 digits (default print with Measurements shows 3 digits)\nprintln(IOContext(stdout, :error_digits=>15), \"A1 = \", A1)\nprintln(IOContext(stdout, :error_digits=>15), \"A2 = \", A2)\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#Results-and-Plotting","page":"Functions","title":"Results and Plotting","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"The simulation result of a model instantiatedModel supports the abstract interface ModiaResult and exports them, so the functions can be accessed without prefixing them with Modia. The following functions are provided (for details see  Functions of ModiaResult):","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"CurrentModule = Modia","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"Functions Description\n@usingModiaPlot Expands into using ModiaPlot_<PlotPackageName>\nusePlotPackage Define the plot package to be used.\nusePreviousPlotPackage Define the previously defined plot package to be used.\ncurrentPlotPackage Return name defined with usePlotPackage\nresultInfo Return info about the result as DataFrame table\nprintResultInfo Print info of the result on stdout.\nrawSignal Return raw signal data given the signal name.\ngetPlotSignal Return signal data prepared for a plot package.\ndefaultHeading Return default heading of a result.\nsignalNames Return all signal names.\ntimeSignalName Return the name of the time signal.\nhasOneTimeSignal Return true if one time signal present.\nhasSignal Return true if a signal name is known.","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"The following functions are available after ENV[\"MODIA_PLOT\"] = XXX or @usingModiaPlot(XXX) have been executed (for details see  Functions of Plot Package):","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"Functions Description\nplot Plot simulation results in multiple diagrams/figures.\nsaveFigure Save figure in different formats on file.\ncloseFigure Close one figure\ncloseAllFigures Close all figures\nshowFigure Show figure in window (only GLMakie, WGLMakie)","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"A Modia variable a.b.c is identified by a String key \"a.b.c\". The legends/labels of the plots are automatically constructed by the names and units of the variables. Example:","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"using Modia\r\n@usingModiaPlot\r\n\r\ninstantiatedModel = @instantiatedModel(...)\r\nsimulate!(instantiatedModel, ...)\r\nplot(instantiatedModel,\r\n     [ (\"phi\", \"r\")        (\"phi\", \"phi2\", \"w\");\r\n       (\"w\", \"w2\", \"phi2\") \"w\"                ],\r\n     heading=\"Matrix of plots\")","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"generates the following plot:","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"(Image: Matrix-of-Plots)","category":"page"},{"location":"Functions.html#PathPlanning","page":"Functions","title":"PathPlanning","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"There are some pre-defined functions to define reference paths","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"PTP_path\r\npathEndTime\r\ngetPosition!\r\ngetPosition\r\ngetIndex\r\ngetPath","category":"page"},{"location":"Functions.html#Modia.PTP_path","page":"Functions","title":"Modia.PTP_path","text":"path = PTP_path(names; positions, v_max, a_max, startTime=0.0)\n\nGenerate a new path object to move as fast as possible from positions[i,:] to positions[i+1,:]. The positions[i,:] can be a set of translational positions in [m], that is absolute distances, and/or rotational positions in  [rad] that is angles. In robotics such a movement is called PTP (Point-To-Point). The signals are constructed in such a way that it is not possible to move faster, given the maximally allowed velocity v_max[j] and the maximally allowed acceleration a_max[j] for signal names[j] and have a velocity of zero at the given positions.\n\nIf there are two or more signals (that is length(names) > 1) then the path is constructed such that all signals are in the same periods in the acceleration, constant velocity and deceleration phase. This means that only one of the signals is at its limits whereas the others are synchronized in such a way that the end point is reached at the same time instant.\n\nFor example, this means that the signals have a velocity of zero at positions[1,:], one of the signals is accelerated with its maximally allowed acceleration until one of the signals reaches its maximally allowed velocity. At a proper time instant, one of the signals is decelerated with the negative value of its maximally allowed acceleration, so that all signals reach positions[2,:] with velocity zero.\n\nThis element is useful to generate a reference signal for a controller which controls, e.g., a drive train, or to drive a flange according to a given acceleration.\n\nExample\n\nusing Modia\n@usingModiaPlot\n\nconst ptp_path = PTP_path([\"angle1\", \"angle2\", \"angle3\"],\n                          positions = [0.0 2.0 3.0;  # angle1=0.0, angle2=2.0, angle3=3.0\n                                       0.5 3.0 4.0;\n                                       0.8 1.5 0.3;\n                                       0.2 1.5 0.8],\n                          startTime = 0.1,\n                          v_max = 2*ones(3),\n                          a_max = 3*ones(3))\nangles = zeros(3)\ngetPosition!(ptp_path, 0.5, angles)   # angles = [0.12, 2.24, 3.24]\npath = getPath(ptp_path)\nplot(path, [\"angle1\", \"angle2\", \"angle3\"])\n\n\n\n\n\n","category":"type"},{"location":"Functions.html#Modia.pathEndTime","page":"Functions","title":"Modia.pathEndTime","text":"Tend = pathEndTime(path)\n\nGiven a path::PTP_path return the end time Tend of the path.\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#Modia.getPosition!","page":"Functions","title":"Modia.getPosition!","text":"getPosition!(path, time, position)\n\nGiven a path::PTP_path and a time instant time, return the actual position at time time in vector position.\n\n\n\n\n\ngetPosition!(path, time, position, velocity, acceleration)\n\nGiven a path::PTP_path and a time instant time, return the actual position, velocity and acceleration at time time in vectors position, velocity, acceleration.\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#Modia.getPosition","page":"Functions","title":"Modia.getPosition","text":"pos = getPosition(path, index, time)\n\nGiven a path::PTP_path, the index of a signal, and a time instant time, return the actual position at time time.\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#Modia.getIndex","page":"Functions","title":"Modia.getIndex","text":"index = getIndex(path, name)\n\nReturn the index of name in path or trigger an error, if not present.\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#Modia.getPath","page":"Functions","title":"Modia.getPath","text":"getPath(path;\n        names=path.names, tend=1.1*path.Tend, ntime=101)\n\nGiven a path::PTP_path, return a dictionary with the time series of the path over time up to tend for all ntime time points.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/Tutorial.html#Modia-Tutorial","page":"Modia Tutorial","title":"Modia Tutorial","text":"","category":"section"},{"location":"tutorial/Tutorial.html","page":"Modia Tutorial","title":"Modia Tutorial","text":"This tutorial gives an overview of package Modia to construct component-based and equation-based models with the Modia language on a high level, symbolically transforming these models into ODEs (Ordinary Differential Equations in state space form), simulating them and plotting result variables.","category":"page"},{"location":"tutorial/Tutorial.html","page":"Modia Tutorial","title":"Modia Tutorial","text":"Note, all examples in this tutorial can be executed with\nusing Modia; include(\"$(Modia.path)/examples/Tutorial.jl\")","category":"page"},{"location":"tutorial/Tutorial.html","page":"Modia Tutorial","title":"Modia Tutorial","text":"Modeling of 3D components is explained in the Modia3D Tutorial","category":"page"},{"location":"tutorial/Tutorial.html","page":"Modia Tutorial","title":"Modia Tutorial","text":"info: Info\nModia has an interface to various plot packages. A plot package can be either selected by setting ENV[\"MODIA_PLOT\"] = XXX, for example in the config/startup.jl file of Julia or by command Modia.usePlotPackage(XXX). Possible values for XXX: \"PyPlot\" (plots with Matplotlib from Python), \n\"GLMakie\" (interactive plots in an OpenGL window),\n\"WGLMakie\" (interactive plots in a browser window),\n\"CairoMakie\" (static plots on file with publication quality),\n\"NoPlot\" (= all plot(...) calls are ignored), or\n\"SilentNoPlot\" (= NoPlot without messages).","category":"page"},{"location":"index.html#Modia-Documentation","page":"Home","title":"Modia Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Modia is an environment in form of a Julia package to model and simulate physical systems (electrical, mechanical, thermo-dynamical, etc.) described by differential and algebraic equations. A user defines a model on a high level with model components (like a mechanical body, an electrical resistance, or a pipe) that are physically connected together. A model component is constructed by expression = expression equations or by Julia structs/functions, such as the pre-defined Modia 3D-mechanical components. The defined model is symbolically processed (for example, equations might be analytically differentiated) with algorithms from package ModiaBase.jl. From the transformed model a Julia function is generated that is used to simulate the model with integrators from DifferentialEquations.jl. The basic type of the floating point variables is usually Float64, but can be set to any type FloatType<:AbstractFloat via @instantiateModel(..., FloatType = xxx), for example it can be set to Float32, DoubleFloat, Measurement{Float64}, StaticParticles{Float64,100}.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package is registered and is installed with (Julia >= 1.7 is required):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add Modia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Furthermore, one or more of the following packages should be installed in order to be able to generate plots:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add ModiaPlot_PyPlot        # if plotting with PyPlot desired\r\n        add ModiaPlot_GLMakie       # if plotting with GLMakie desired\r\n        add ModiaPlot_WGLMakie      # if plotting with WGLMakie desired\r\n        add ModiaPlot_CairoMakie    # if plotting with CairoMakie desired","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note, Modia exports all exported symbols of ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"DifferentialEquations and of \nUnitful","category":"page"},{"location":"index.html#Release-Notes","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Version-0.8.1","page":"Home","title":"Version 0.8.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Missing file Modia/test/TestLinearEquations.jl added.","category":"page"},{"location":"index.html#Version-0.8.0","page":"Home","title":"Version 0.8.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Non-backwards compatible changes","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The Modia packages are slightly restructured to allow more efficient operations. Previously, Modia was planned to include all the functionality with all model libraries. This is now changed and Modia includes now equation-oriented modeling and basic model libraries. Further model libraries, such as Modia3D (and other model libraries in the future) must be explicitly imported and are no longer automatically imported by Modia. To simplify the structuring, ModiaLang is merged into Modia and some functionality for the code generation is moved from ModiaBase to Modia. Overall, the benefit is that loading and compilation times are reduced, if Modia3D is not needed. Furthermore, the generated code contains only references to Modia functionality and no longer to ModiaBase. Details of the changes:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ModiaLang#main 0.11.3 and ModiaLang#development merged into Modia 0.7.0 resulting in the new Modia version 0.8.0 (hereby history of both ModiaLang and of Modia is preserved).\nModia3D is removed from Modia (so when a model is using Modia3D, the package must be explicitly imported and is no longer automatically imported from Modia).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Require ModiaBase 0.10 (where EquationAndStateInfo.jl and StateSelection.jl are removed and added to Modia, in order that only references to Modia are in the generated code and no longer references to ModiaBase).","category":"page"},{"location":"index.html#Old-Release-Notes-(until-28.2.2022)","page":"Home","title":"Old Release Notes (until 28.2.2022)","text":"","category":"section"},{"location":"index.html#Release-Notes-of-Modia-(until-28.2.2022)","page":"Home","title":"Release Notes of Modia (until 28.2.2022)","text":"","category":"section"},{"location":"index.html#Version-0.7.0","page":"Home","title":"Version 0.7.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Non-backwards compatible changes (basically, these changes are, erronously, in 0.6.1):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Equations can only be defined with key equations and no other key (still, expressions can be associated with one variable, such as b = Var(:(2*a))). In versions 0.6.0 and before, equations could be associated with any key.\nThe merge operator | appends the expression vectors of equations, so  m1 | m2 basically appends the vector of m2.equations to the vector of m1.equations. In versions 0.6.0 and before, the merge operator did not handle equations specially,  and therefore m1 | m2 replaced m1.equations by m2.equations.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Parameter values in the code are now type cast to the type of the parameter value from the  @instantiatedModel(..) call. The benefit is that access of parameter values in the code is type stable and operations with the parameter value are more efficient and at run-time no memory is allocated. Existing models can no longer be simulated, if parameter values provided via simulate!(.., merge=xx) are not type compatible to their definition. For example, an error is thrown if the @instantedModel(..) uses a Float64 value and the simulate!(.., merge=xx) uses a Measurement{Float64} value for the same parameter\nOperator buildModia3D(..) as used in Modia3D models is removed. Instead, the new constructor  Model3D(..) must be used at the top level of a Modia3D definition. It is now possible to define  several, independent multibody systems (currently, only one of them can have animation and animation export). \nVar(init=[...]) or Var(start=[..]) of FreeMotion joints must be defined as Var(init=SVector{3,Float64}(..)) or Var(start=SVector{3,Float64}(..)). Otherwise, errors occur during compilation. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Other changes","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Documentation (especially tutorial) adapted to the new version.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Examples and test models (Modia/examples, Modia/tests) adapted to the new version, especially to the non-backwards compatible changes.\nFor further changes of equation-based models, see the release notes of ModiaLang 0.11.0.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For further changes of Modia3D models, see the release notes of Modia3D 0.9.0.","category":"page"},{"location":"index.html#Version-0.6.1","page":"Home","title":"Version 0.6.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This version was erronously released as 0.6.1. Since it contains non-backwards compatible changes with respect to 0.6.0, this is wrong and should have been released as version 0.7.0.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"See release notes of ModiaLang and  of Modia3D.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Project.toml and Manifest.toml updated due to new versions of Modia3D and ModiaLang","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"docu: fix some typing and formatting","category":"page"},{"location":"index.html#Version-0.6.0","page":"Home","title":"Version 0.6.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Modia is restricted to Julia 1.7\ncyclic dependencies with Modia3D package are removed","category":"page"},{"location":"index.html#Version-0.5.2","page":"Home","title":"Version 0.5.2","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Fully reexporting Modia3D and removing duplicate ModiaInterface (see Modia3D release notes 0.6.0).","category":"page"},{"location":"index.html#Version-0.5.1","page":"Home","title":"Version 0.5.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Using and reexporting ModiaLang 0.8.3 (see release notes 0.8.3 and 0.8.2).\nUsing and partially reexporting Modia3D 0.5.1 (see release notes 0.5.1).","category":"page"},{"location":"index.html#Version-0.5.0","page":"Home","title":"Version 0.5.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Using and reexporting ModiaLang 0.8.1 (see release notes).\nUsing and partially reexporting Modia3D 0.5.0 (see release notes).\nNew plot package interface via ModiaResult. Additional support for PyPlot, WGLMakie, CairoMakie (besides GLMakie).","category":"page"},{"location":"index.html#Version-0.4.0","page":"Home","title":"Version 0.4.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Initial version of new Modia design.","category":"page"},{"location":"index.html#Release-Notes-of-ModiaLang-(until-28.2.2022)","page":"Home","title":"Release Notes of ModiaLang (until 28.2.2022)","text":"","category":"section"},{"location":"index.html#Version-0.11.3","page":"Home","title":"Version 0.11.3","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"@instantiateModel(..): Var(hideResult=true) is no longer ignored if present in a sub-component.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"simulate!(..): Unnecessary evaluation of the parameters dictionary is avoided  (if merge = missing, nothing or has no elements).","category":"page"},{"location":"index.html#Version-0.11.2","page":"Home","title":"Version 0.11.2","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Minor (efficiency) improvement if states are SVectors.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Require ModiaBase 0.9.2 (to get rid of performance issues in Modia3D).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Replace ustrip(..) with ustrip.(..) at some places to get rid of warnings.","category":"page"},{"location":"index.html#Version-0.11.1","page":"Home","title":"Version 0.11.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Update of Manifest.toml file\nRequire ModiaBase 0.9.1 (with updated Manifest.toml file)","category":"page"},{"location":"index.html#Version-0.11.0","page":"Home","title":"Version 0.11.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Non-backwards compatible changes","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Equations can only be defined with key equations and no other key. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Parameter values in the code are now type cast to the type of the parameter value from the  @instantiatedModel(..) call. The benefit is that access of parameter values in the code is type stable and operations with the parameter value are more efficient and at run-time no memory is allocated. Existing models can no longer be simulated, if parameter values provided via simulate!(.., merge=xx) are not type compatible to their definition. For example, an error is thrown if the @instantedModel(..) uses a Float64 value and the simulate!(.., merge=xx) uses a Measurement{Float64} value for the same parameter","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Other changes","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Hierarchical names in function calls supported (e.g. a.b.c.fc(..)). ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Functions can return multiple values, e.g. (tau1,tau2) = generalizedForces(derw1, derw2).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Support for StaticArrays variables (the StaticArrays feature is kept in the generated AST). For an example, see ModiaLang/test/TestArrays.jl.\nSupport for Array variables (especially of state and tearing variables) where the dimension can change after @instantiateModel(..). For examples, see ModiaLang/test/TestArrays.jl and TestMultiReturningFunction10.jl.\nNew keyword Var(hideResult=true) removes variable from the result (has no effect on states, derivative of states and parameters). For an example, see ModiaLang/test/TestMultiReturningFunction10.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"New feature of @instantiatedModel(..): If a Model(..) has key :_buildFunction, call this function to merge additional code to the model. For details see the docu of function buildSubModels! in ModiaLang.jl. For examples, see ModiaLang/test/TestMultiReturningFunction10.jl and  constructor Model3D(..) in Modia3D/src/ModiaInterface/model3D.jl and Modia3D/src/ModiaInterface/buildModia3D.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Generalized connection semantics.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Functions converting model to/from JSON: modelToJSON(model), JSONtoModel(json_string)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"simulate!(..):\nNew option logProgress=false in function simulate!(..) to print current simulation time every 5s (cpu-time).\nIf tolerance is too small, a warning is prented and it is automatically enlarged to a meaningful value (e.g. tolerance = 1e-8 is not useful if FloatType=Float32)\nLogging improved: If log=true or logTiming=true, then timing, memory allocation and compilation time is  reported for initialization (ths includes compilation of the generated getDerivatives(..) function).  The remaining log shows cpu-time and memory allocation without initialization  (and without the resources needed to compile getDerivatives(..)).\nPrefix messages of the timers with \"ModiaLang\" or \"DifferentialEquations\" to more clearly see the origin of a message in the timer log.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Large speedup of symbolic transformation, if function depends on many input (and output) arguments  (includes new operator implicitDependency(..)).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Included DAE-Mode in solution of linear equation system (if DAE integrator is used and all unknowns of a linear equation system are part of the DAE states, solve the linear equation system during continuous integration via DAE solver (= usually large simulation speed-up, for larger linear equation systems)  ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Bug fixes","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If unitless=true, units in instantiatedModel.evaluatedParameters are removed.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The unit macro is kept in the generated code and is no longer expanded. For example, u\"N\", is kept in the code that is displayed with logCode=true (previously, this was expanded and the unit was displayed in the code as N which is not correct Julia code).\nFunction ModiaLang.firstInitialOfAllSegments(..) now correctly returns true for the first call of the getDerivatives function during the simulation.","category":"page"},{"location":"index.html#Version-0.10.2","page":"Home","title":"Version 0.10.2","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Minor (efficiency) improvement if states are SVectors.\nRequire ModiaBase 0.9.2 (to get rid of performance issues in Modia3D).\nReplace ustrip(..) with ustrip.(..) at some places to get rid of warnings.","category":"page"},{"location":"index.html#Version-0.10.1","page":"Home","title":"Version 0.10.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Update of Manifest.toml file\nRequire ModiaBase 0.9.1 (with updated Manifest.toml file).","category":"page"},{"location":"index.html#Version-0.10.0","page":"Home","title":"Version 0.10.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Require DifferentialEquations.jl version 7.\nCleanup of using/export\nCleanup of Project.toml/Manifest.toml.´\n@reexport using Unitful\n@reexport using DifferentialEquations\nCleanup of test files (besides ModiaLang, no other package needed in the environment to run the tests).\nChange SimulationModel{FloatType,ParType,EvaluatedParType,TimeType} to SimulationModel{FloatType,TimeType}","category":"page"},{"location":"index.html#Version-0.9.1","page":"Home","title":"Version 0.9.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"New function plotPath to plot a PTP_path\nReplace ustrip(..) with ustrip.(..) at some places to get rid of warnings.\nInclude time in error message, if simulation failed","category":"page"},{"location":"index.html#Version-0.9.0","page":"Home","title":"Version 0.9.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Require Julia 1.7\nUpgrade Manifest.toml to version 2.0\nUpdate Project.toml/Manifest.toml","category":"page"},{"location":"index.html#Version-0.8.7","page":"Home","title":"Version 0.8.7","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Packages used in test models, prefixed with ModiaLang. to avoid missing package errors.\nDeactivating test with DoubleFloats, since not in Project.toml\nVersion/date updated","category":"page"},{"location":"index.html#Version-0.8.6","page":"Home","title":"Version 0.8.6","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Require ModiaResult, version 0.3.9\nProject.toml/Manifest.toml updated","category":"page"},{"location":"index.html#Version-0.8.5","page":"Home","title":"Version 0.8.5","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"simulate!(..): \nTrigger an error, if simulation is not successful (retcode is neither :Default nor :Success nor :Terminate)\nUse RightRootFind for zero crossings (improves state events based on new DifferentialEquations option)\nNew keyword argument requiredFinalStates_atol=0.0.\nImprove docu (e.g. add return argument solution).  \nShow correct integrator name QBDF in simulation log (instead of QNDF)\nRaise an error, if (relative) tolerance is too small for FloatType\nUse FloatType for zero crossing hysteresis, instead of Float64\nIf log=true print info about end of initialization.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Support of MonteCarloMeasurements with units + new test model TestLinearEquationSystemWithUnitsAndMonteCarlo.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Fixing and activating the deactivated test TestTwoInertiasAndIdealGearWithUnitsAndMonteCarlo.jl.","category":"page"},{"location":"index.html#Version-0.8.4","page":"Home","title":"Version 0.8.4","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"FloatType is included in the name space of Core.eval when evaluating parameters.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Version and Date updated","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Included Version in printout of runtests.jl and runtests_withPlot.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Print difference of finalStates and requiredFinalStates in case they do not match with the given tolerance.","category":"page"},{"location":"index.html#Version-0.8.3","page":"Home","title":"Version 0.8.3","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Project.toml, Manifest.toml updated: Require newest version 0.7.7 of ModiaBase (containing a bug fix)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Minor correction of simulate!(log=true) output","category":"page"},{"location":"index.html#Version-0.8.2","page":"Home","title":"Version 0.8.2","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Issue with tearing fixed: Variables are only explicitly solved, if linear factor is a non-zero literal number (previously a division by zero could occur, if the linear factor became zero during simulation).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Issue with unit of tearing variable fixed, if it is a derivative of a variable (previously, the generated code for unitless=false was wrong, if the tearing variable was  a derivative, since the unit was not taken into account).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"simulate!(..): \nSupport DAE integrators, especially IDA() from Sundials.\nNew keyword useRecursiveFactorizationUptoSize=0: Linear equation systems A*v=b are solved with RecursiveFactorization.jl instead of  the default lu!(..) and ldiv!(..), if length(v) <= useRecursiveFactorizationUptoSize. According to RecursiveFactorization.jl docu, it is faster as lu!(..) with OpenBLAS, for length(v) <= 500 (typically, more as a factor of two).  Since there had been some cases where lu!(..)! was successful, but RecursiveFactorization.jl failed due to a singular system, the default is to use lu!(..)!.\nIf log=true, sizes of linear equation systems are listed, as well as whether  RecursiveFactorization.jl is used for the respective system.\nTest for RecursiveFactorization.jl added in TestTwoInertiasAndIdealGear.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Some test models corrected (since leading to errors with the above changes).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Updated Project.toml and Manifest.toml with newest versions of packages (including MonteCarloMeasurements, version >= 1) and improved Project.toml file to reduce issues with package constraints","category":"page"},{"location":"index.html#Version-0.8.1-2","page":"Home","title":"Version 0.8.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Added a minimal documentation, including release notes.\nNo message anymore, when ModiaLang is started.\nFixed bug that using ModiaResult is needed, when calling @usingModiaPlot.","category":"page"},{"location":"index.html#Version-0.8.0-2","page":"Home","title":"Version 0.8.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Improved scalability by using OrderedDicts instead of named tuples for models, variables and parameter modifications.\nSpeed improvements for structural and symbolic algorithms.\nAdded support for state events, time events and synchronous operators.\nAdded support for mixed linear equation systems having Real and Boolean unknowns.\nAdded support for user-defined components defined by structs and functions (multibody modeling with Modia3D is based on this feature). This makes it possible to utilize algorithms specialized for a component.\nAdded support for numerical and analytic linearization.\nAdded support for propagation of parameters (e.g. deep in a model, the value of a parameter can be defined as a function of some top level parameter and this parameter is changed before simulation starts).\nNew small model libraries Translational.jl and PathPlanning.jl added.\nResult storage changed: sol = simulate!(...) calls internally sol = solve(..) from   DifferentialEquations.jl. sol contains time and the states at the communication time grid and at events. This is now kept in simulate(..), so the return value of simulate!(..) can be exactly used as if solve(..) would have been used directly.\nThe plot(..) command now supports the following underlying plot packages:  PyPlot, GLMakie, WGLMakie, and CairoMakie. It is also possible to select NoPlot, to ignore plot(..) calls  or SilenNoPlot to ignore plot(..) calls silently. The latter is useful for runtests.jl. Note, often PyPlot is the best choice.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Changes that are not backwards compatible to version 0.7.x:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Models are OrderedDicts and no longer NamedTuples.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"simulate!(..): \nIf FloatType=Float64 and no algorithm is defined, then Sundials.CVODE_BDF() is used instead of the default algorithm of DifferentialEquations as in 0.7. The reason is that Modia models are usually large and expensive to evaluate and have often stiff parts, so that multi-step methods are often by far the best choice. CVODE_BDF() seems to be a good choice in many applications (another algorithm should be used, if there are many events, highly oscillatory vibrations, or if all states are non-stiff). \nThe default value of stopTime is equal to startTime (which has a default value of 0.0 s), and is no longer 1.0 s.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Plotting is defined slightly differently (@useModiaPlot, instead of using ModiaPlot).","category":"page"},{"location":"index.html#Version-0.7.3","page":"Home","title":"Version 0.7.3","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Evaluation and propagation of parameter expressions (also in simulate!(..., merge=Map(...))). Propagation of start/init values of states is not yet supported.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"State events supported.","category":"page"},{"location":"index.html#Version-0.7.2","page":"Home","title":"Version 0.7.2","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Missing dependency of Test package added.","category":"page"},{"location":"index.html#Version-0.7.1","page":"Home","title":"Version 0.7.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Variable constructor Var(...) introduced. For example: v = input | Var(init = 1.2u\"m\"). ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Functions are called in the scope where macro @instantiateModel is called.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"New arguments of function simulate!:\nParameter and init/start values can be changed with argument merge.\nA simulation can be checked with argument requiredFinalStates.\nArgument logParameters lists the parameter and init/start values used for the simulation.\nArgument logStates lists the states, init, and nominal values used for the simulation.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"end in array ranges is supported, for example v[2:end].","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"New (small) model library Modia/models/HeatTransfer.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Modia Tutorial improved.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Functions docu improved.","category":"page"},{"location":"index.html#Version-0.7.0-2","page":"Home","title":"Version 0.7.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Initial version, based on code developed for Modia 0.6 and ModiaMath 0.6.","category":"page"},{"location":"index.html#Main-developers","page":"Home","title":"Main developers","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Hilding Elmqvist, Mogram.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Martin Otter, DLR - Institute of System Dynamics and Control.","category":"page"}]
}
