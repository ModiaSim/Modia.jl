<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2 Modeling · Modia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Modia</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="Tutorial.html">Modia Tutorial</a></li><li><a class="tocitem" href="GettingStarted.html">1 Getting Started</a></li><li class="is-active"><a class="tocitem" href="Modeling.html">2 Modeling</a><ul class="internal"><li><a class="tocitem" href="#.1-Equation-oriented-models"><span>2.1 Equation oriented models</span></a></li><li><a class="tocitem" href="#.2-Merging-models"><span>2.2 Merging models</span></a></li><li><a class="tocitem" href="#.3-Functions-and-tables"><span>2.3 Functions and tables</span></a></li><li><a class="tocitem" href="#.4-Hierarchical-modeling"><span>2.4 Hierarchical modeling</span></a></li><li><a class="tocitem" href="#.5-Physically-oriented-modeling"><span>2.5 Physically oriented modeling</span></a></li><li><a class="tocitem" href="#.6-Arrays"><span>2.6 Arrays</span></a></li><li><a class="tocitem" href="#.7-Model-libraries"><span>2.7 Model libraries</span></a></li></ul></li><li><a class="tocitem" href="Simulation.html">3 Simulation</a></li><li><a class="tocitem" href="FloatingPointTypes.html">4 Floating Point Types</a></li><li><a class="tocitem" href="Appendix.html">Appendix A</a></li></ul></li><li><a class="tocitem" href="../Functions.html">Functions</a></li><li><a class="tocitem" href="../Internal.html">Internal</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href="Modeling.html">2 Modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Modeling.html">2 Modeling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ModiaSim/Modia.jl/blob/main/docs/src/tutorial/Modeling.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">2 Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h1><h2 id=".1-Equation-oriented-models"><a class="docs-heading-anchor" href="#.1-Equation-oriented-models">2.1 Equation oriented models</a><a id=".1-Equation-oriented-models-1"></a><a class="docs-heading-anchor-permalink" href="#.1-Equation-oriented-models" title="Permalink"></a></h2><p>A low pass filter block with input <code>u</code> and output <code>y</code></p><p class="math-container">\[\begin{aligned}
T \cdot \frac{dx}{dt} + x &amp;= u\\
     y &amp;= x \\
x(t_0) &amp;= 0
\end{aligned}\]</p><p>can be defined as:</p><pre><code class="language-julia hljs">using Modia

LowPassFilter = Model(
    T = 0.2,
    u = input,
    y = output | Var(:x),
    x = Var(init=0),
    equations = :[T * der(x) + x = u],
)</code></pre><p>The symbols <code>input</code> and <code>output</code> refer to predefined variable constructors to define the input and output variables. If an equation has just a unique variable in the left hand side, <code>y</code>, the right hand side can be given as a quoted expression in a Var-constructor <code>Var(:x)</code> after the <code>output</code> constructor combined with the merge operator, <code>|</code>, see below.</p><h2 id=".2-Merging-models"><a class="docs-heading-anchor" href="#.2-Merging-models">2.2 Merging models</a><a id=".2-Merging-models-1"></a><a class="docs-heading-anchor-permalink" href="#.2-Merging-models" title="Permalink"></a></h2><p>It is possible to combine models by merging. If we want to change the model to become a highpass filter, an alternative output equation</p><p class="math-container">\[y = -x + u\]</p><p>is defined in an anonymous model <code>Model( y = :(-x + u) )</code>. This anonymous model is merged with <code>LowPassFilter</code> using the merge operator <code>|</code>:</p><pre><code class="language-julia hljs">HighPassFilter = LowPassFilter | Model( y = Var(:(-x + u) ) )</code></pre><p>The merging implies that the <code>output</code> property of <code>y</code> is kept, but the binding expression is changed from <code>:x</code> to <code>:(-x + u)</code>.</p><p>In general, recursive merging is desired and Modia provides a <code>mergeModels</code> function for that (see appendix <a href="Appendix.html#A.3-MergeModels-algorithm">A.3 MergeModels algorithm</a>). This function is invoked as a binary operator <code>|</code> (also used for merge in Python). Note, that the order of the arguments/operands are important.</p><p>Generalizing the block to have two outputs for both low and high pass filtering would be done as follows:</p><pre><code class="language-julia hljs">LowAndHighPassFilter = LowPassFilter | Model(
        y = nothing,
        low = output | Var(:x),
        high = output | Var(:(-x + u)),
    )</code></pre><p>The equation for <code>y</code> is removed by &quot;assigning&quot; <code>nothing</code> and two variables are defined and declared as outputs.</p><p>Model <code>LowAndHighPassFilter</code> represents the following equations:</p><p class="math-container">\[\begin{aligned}
T \cdot \frac{dx}{dt} + x &amp;= u\\
     low &amp;= x \\
    high &amp;= -x + u \\
x(t_0) &amp;= 0
\end{aligned}\]</p><p>By turning on logging of merging <code>setLogMerge(true)</code>, the translator gives the log:</p><pre><code class="language-julia hljs">Adding: value = :(x)
Adding: value = :(-x + u)
Deleting: y
Adding: low = Var(
      output = true,
      value = :(x),
    ),
Adding: high = Var(
      output = true,
      value = :(-x + u),
    ),</code></pre><p>The resulting model is pretty printed by calling <code>@showModel LowAndHighPassFilter</code>:</p><pre><code class="language-julia hljs">LowAndHighPassFilter = Model(
  T = 0.2,
  u = Var(
    input = true,
  ),
  x = Var(
    init = 0.0 V,
  ),
  equations = :([T * der(x) + x = u]),
  low = Var(
    output = true,
    value = :(x),
  ),
  high = Var(
    output = true,
    value = :(-x + u),
  ),
),</code></pre><h2 id=".3-Functions-and-tables"><a class="docs-heading-anchor" href="#.3-Functions-and-tables">2.3 Functions and tables</a><a id=".3-Functions-and-tables-1"></a><a class="docs-heading-anchor-permalink" href="#.3-Functions-and-tables" title="Permalink"></a></h2><p>In order to test an input/output block as defined in the previous section, an input needs to be defined. This can be made by adding an equation for <code>u</code>. Assume we want <code>u</code> to be sinousoidial with an increasing frequency:</p><pre><code class="language-julia hljs">TestLowAndHighPassFilter = LowAndHighPassFilter | Model(
        u = :(sin( (time+1u&quot;s&quot;)*u&quot;1/s/s&quot; * time)*u&quot;V&quot;),
        x = Var(init=0.2u&quot;V&quot;)
    )</code></pre><p><code>time</code> is a reserved name for the independent variable. It has unit <code>s</code> for seconds. The Julia package <a href="https://painterqubits.github.io/Unitful.jl/stable/">Unitful</a> provides a means for defining units and managing unit inference. It need not be explicitly defined, because its symbols are exported by <code>using Modia</code>. Definition of units is done with a string macro <code>u&quot;...&quot;</code>. In this case, the input signal was given unit Volt. The state x must then also have consistent unit, that is Volt. If the model equations contain systems of simultaneous equations, then approximate guess values, optionally with units, must be given <code>start</code>: <code>i = Var(start=0.0u&quot;A&quot;)</code>.</p><p>The input signal can also be defined by interpolation in a table:</p><pre><code class="language-julia hljs">using Interpolations

table = CubicSplineInterpolation(0:0.5:2.0, [0.0, 0.7, 2.0, 1.8, 1.2])
TestLowAndHighPassFilter2 = TestLowAndHighPassFilter | Map(u = :(table(time*u&quot;1/s&quot;)*u&quot;V&quot;))</code></pre><p>It is possible to call Julia functions that have more as one return argument:</p><pre><code class="language-julia hljs">function ref(time)
    y1 = sin(time)
    y2 = cos(time)
    return (y1,y2)
end

TestMultiReturningFunction1 = Model(
    equations = :[
        (y1,y2) = ref(time)
        y3 = y1+y2
    ]
)</code></pre><p>The returned arguments are typically numbers or arrays (see below). It is also possible to return an instance of a struct and, say, pass this instance as input to another function call.</p><p>It is currently not supported that a function call modifies one of its arguments, or that a function call returns no argument at all:</p><pre><code class="nohighlight hljs">equations = :[
    fc!(u,y)                   # Error: Not known that fc! computes y
    println(&quot;This is a test&quot;)  # Error: One equation is introduced but no unknown
]</code></pre><h2 id=".4-Hierarchical-modeling"><a class="docs-heading-anchor" href="#.4-Hierarchical-modeling">2.4 Hierarchical modeling</a><a id=".4-Hierarchical-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#.4-Hierarchical-modeling" title="Permalink"></a></h2><p>So far, the composition of models has resulted in dictionaries of key/value pairs with values being numeric values or quoted expressions. Hierarchical models are obtained if the values themselves are <code>Models</code>, i.e. dictionaries. A model with two filters can, for example, be defined as follows:</p><pre><code class="language-julia hljs">TwoFilters = (
    high = HighPassFilter,
    low = LowPassFilter,
)</code></pre><p>Note, that the previous definitions of <code>HighPassFilter</code> and <code>LowPassFilter</code> was used instead of making the Model definitions inline.</p><p>A band pass filter is a series connection of a high pass filter and a low pass filter and can be described as:</p><pre><code class="language-julia hljs">BandPassFilter = (
    u = input,
    y = output,
    high = HighPassFilter | Map(T=0.5, x=Var(init=0.1u&quot;V&quot;)),
    low = LowPassFilter | Map(x=Var(init=0.2u&quot;V&quot;)),
    equations = :[
        high.u = u,
        low.u = high.y,
        y = low.y]
)</code></pre><p>A new input, <code>u</code>, has been defined which is propagated to <code>high.u</code>. The series connection itself is obtained by the equation <code>low.u = high.y</code>. Note, that dot-notation is allowed in equations.</p><p>The input and output for the <code>BandPassFilter</code> when using the same input definition as for the <code>TestLowPassFilter</code></p><pre><code class="language-julia hljs">TestBandPassFilter = BandPassFilter | Map(
        u = :(sin( (time+1u&quot;s&quot;)*u&quot;1/s/s&quot; * time)*u&quot;V&quot;)
    )
bandPassFilter = @instantiateModel(TestBandPassFilter)
simulate!(bandPassFilter, Tsit5(), stopTime = 50u&quot;s&quot;)
plot(bandPassFilter, [&quot;u&quot;, &quot;y&quot;], figure=2)</code></pre><p>is shown below:</p><p><img src="../../resources/images/BandPassFilterPlot.png" alt="Band Pass Filter Plot"/></p><h2 id=".5-Physically-oriented-modeling"><a class="docs-heading-anchor" href="#.5-Physically-oriented-modeling">2.5 Physically oriented modeling</a><a id=".5-Physically-oriented-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#.5-Physically-oriented-modeling" title="Permalink"></a></h2><p>So far, only signal flow modeling has been used, i.e. input/output blocks coupled with equations between outputs and inputs. For object oriented modeling more high level constructs are necessary. Coupling is then acausal and involves potentials such as electric potential, positions, pressure, etc. and flows such as electric current, forces and torques and mass flow rate.</p><h3 id=".5.1-Connectors"><a class="docs-heading-anchor" href="#.5.1-Connectors">2.5.1 Connectors</a><a id=".5.1-Connectors-1"></a><a class="docs-heading-anchor-permalink" href="#.5.1-Connectors" title="Permalink"></a></h3><p>Models which contain any <code>flow</code> variable, i.e. a variable having an attribute <code>flow=true</code>, are considered connectors. Connectors must have equal number of flow and potential variables, i.e. variables having an attribute <code>potential=true</code>, and have matching array sizes. Connectors may not have any equations. An example of an electrical connector with potential (in Volt) and current (in Ampere) is shown below.</p><pre><code class="language-julia hljs">Pin = Model( v = potential, i = flow )</code></pre><p>The value <code>potential</code> is a shortcut for <code>Var(potential=true)</code> and similarly for <code>flow</code>.</p><h3 id=".5.2-Components"><a class="docs-heading-anchor" href="#.5.2-Components">2.5.2 Components</a><a id=".5.2-Components-1"></a><a class="docs-heading-anchor-permalink" href="#.5.2-Components" title="Permalink"></a></h3><p>Components are declared in a similar ways as blocks. However, the interfaces between components are defined using connector instances.</p><p>An electrical resistor can be described as follows:</p><pre><code class="language-julia hljs">Resistor = Model(
    R = 1.0u&quot;Ω&quot;,
    p = Pin,
    n = Pin,
    equations = :[
        0 = p.i + n.i
        v = p.v - n.v
        i = p.i
        R*i = v ]
    )</code></pre><h3 id=".5.3-Inheritance"><a class="docs-heading-anchor" href="#.5.3-Inheritance">2.5.3 Inheritance</a><a id=".5.3-Inheritance-1"></a><a class="docs-heading-anchor-permalink" href="#.5.3-Inheritance" title="Permalink"></a></h3><p>Various physical components sometimes share common properties. One mechanism to handle this is to use inheritance. In Modia, <strong>merging</strong> is used.</p><p>Electrical components such as resistors, capacitors and inductors are categorized as oneports which have two pins. Common properties are: constraint on currents at the pins and definitions of voltage over the component and current through the component.</p><pre><code class="language-julia hljs">OnePort = Model(
    p = Pin,
    n = Pin,
    equations = :[
        0 = p.i + n.i
        v = p.v - n.v
        i = p.i ] )</code></pre><p>Having such a <code>OnePort</code> definition makes it convenient to define electrical component models by merging <code>OnePort</code> with specific parameter definitions with default values and equations:</p><pre><code class="language-julia hljs">Resistor = OnePort | Model( R = 1.0u&quot;Ω&quot;, equations = :[ R*i = v ], )

Capacitor = OnePort | Model( C = 1.0u&quot;F&quot;, v=Map(init=0.0u&quot;V&quot;), equations = :[ C*der(v) = i ] )

Inductor = OnePort | Model( L = 1.0u&quot;H&quot;, i=Map(init=0.0u&quot;A&quot;), equations = :[ L*der(i) = v ] )

ConstantVoltage = OnePort | Model( V = 1.0u&quot;V&quot;, equations = :[ v = V ] )</code></pre><p>The merged <code>Resistor</code> is shown below:</p><pre><code class="language-julia hljs">Resistor = Model(
  p = Model(
    v = Var(potential = true),
    i = Var(flow = true),
  ),
  n = Model(
    v = Var(potential = true),
    i = Var(flow = true),
  ),
  equations = :([v = p.v - n.v; 0 = p.i + n.i; i = p.i, R * i = v]),
  R = 1.0 Ω,
),</code></pre><p>Note, there is a special merge-rule that the vectors of keys <code>equations</code> are appended.</p><h3 id=".5.4-Connections"><a class="docs-heading-anchor" href="#.5.4-Connections">2.5.4 Connections</a><a id=".5.4-Connections-1"></a><a class="docs-heading-anchor-permalink" href="#.5.4-Connections" title="Permalink"></a></h3><p>Connections are described as an array of tuples listing the connectors that are connected:</p><pre><code class="language-julia hljs">    ( &lt;connect reference 1&gt;, &lt;connect reference 2&gt;, ... )</code></pre><p>A connect reference has either the form &#39;connect instance name&#39; or &#39;component instance name&#39;.&#39;connect instance name&#39; with &#39;connect instance name&#39; being either a connector instance, input or output variable.</p><p>Examples</p><pre><code class="language-julia hljs">    connect = :[
      (V.p, R1.p)
      (R1.n, p)
      (C1.n, V.n, R2.p)
      ...
    ]</code></pre><p>For connectors, all the potentials of the connectors in the same connect tuple are set equal and the sum of all incoming flows to the model are set equal to the sum of the flows into sub-components. A Modelica inspired form of connections, i.e. connect-equations, are also supported:</p><pre><code class="language-julia hljs">    equations = :[
      connect(V.p, R1.p)
      connect(R1.n, p)
      connect(C1.n, V.n, R2.p)
      ...
    ]</code></pre><h3 id=".5.5-Connected-models"><a class="docs-heading-anchor" href="#.5.5-Connected-models">2.5.5 Connected models</a><a id=".5.5-Connected-models-1"></a><a class="docs-heading-anchor-permalink" href="#.5.5-Connected-models" title="Permalink"></a></h3><p>Having the above electrical component models, enables defining a filter</p><p><img src="../../resources/images/Filter.png" alt="Filter Circuit"/></p><p>by instantiating components, setting parameters and defining connections.</p><pre><code class="language-julia hljs">Filter = (
    R = Resistor | Map(R=0.5u&quot;Ω&quot;),
    C = Capacitor | Map(C=2.0u&quot;F&quot;),
    V = ConstantVoltage | Map(V=10.0u&quot;V&quot;),
    connect = :[
      (V.p, R.p)
      (R.n, C.p)
      (C.n, V.n)
    ]
)</code></pre><p>The connect tuples are translated to:</p><pre><code class="language-julia hljs">  V.p.v = R.p.v
  0 = V.p.i + R.p.i
  R.n.v = C.p.v
  0 = R.n.i + C.p.i
  C.n.v = V.n.v
  0 = C.n.i + V.n.i</code></pre><h3 id=".5.6-Parameter-propagation"><a class="docs-heading-anchor" href="#.5.6-Parameter-propagation">2.5.6 Parameter propagation</a><a id=".5.6-Parameter-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#.5.6-Parameter-propagation" title="Permalink"></a></h3><p>Hierarchical modification of parameters is powerful but sometimes a bit inconvenient. It is also possible to propagate parameters introduced on a high level down in the hierarchy. The following Filter model defines three parameters, <code>r</code>, <code>c</code> and <code>v</code>. The <code>r</code> parameter is used to set the resistance of the resistor R: <code>Map(R=:r)</code>.</p><pre><code class="language-julia hljs">Filter2 = Model(
    r = 2.0u&quot;Ω&quot;,
    c = 1.0u&quot;F&quot;,
    v = 10u&quot;V&quot;,
    R = Resistor | Map(R=:r),
    C = Capacitor | Map(C=:c),
    V = ConstantVoltage | Map(V=:v),
    connect = :[
      (V.p, R.p)
      (R.n, C.p)
      (C.n, V.n)
    ]
)</code></pre><p>Two separate filters can then be defined with:</p><pre><code class="language-julia hljs">TwoFilters = Model( f1 = Filter | Map( r = 10.0, c = 2.0), f2 = Filter )</code></pre><h3 id=".5.7-Re-declarations"><a class="docs-heading-anchor" href="#.5.7-Re-declarations">2.5.7 Re-declarations</a><a id=".5.7-Re-declarations-1"></a><a class="docs-heading-anchor-permalink" href="#.5.7-Re-declarations" title="Permalink"></a></h3><p>It is possible to reuse a particular model topology by redeclaring the models of particular components. For example, changing the filter <code>f1</code> to a voltage divider by changing <code>C</code> from a Capacitor to a Resistor. A predefined definition <code>redeclare</code> is used for this purpose.</p><pre><code class="language-julia hljs">VoltageDividerAndFilter = TwoFilters | Map(f1 = Map(C = redeclare | Resistor | Map(R = 20.0)))</code></pre><p>By using <code>redeclare</code>, a new model based on a Resistor is used for <code>C</code> and the usual merge semantics with the previously defined model of <code>C</code> is not used.</p><p>The above examples are available in file <code>FilterCircuit.jl</code>.</p><h3 id=".5.8-Drive-train-example"><a class="docs-heading-anchor" href="#.5.8-Drive-train-example">2.5.8 Drive train example</a><a id=".5.8-Drive-train-example-1"></a><a class="docs-heading-anchor-permalink" href="#.5.8-Drive-train-example" title="Permalink"></a></h3><p>A larger example that utilizes most of the previously described features of Modia is available as <code>$(Modia.path)/examples/ServoSystem.jl</code>. This is a textual (Modia) representation of a Modelica model</p><p><img src="../../resources/images/ServoSystem.png" alt="ServoSystem"/></p><p>and demonstrates how to build up a hierarchical, multi-domain model consisting of a servo-system with a load, where the servo-system consists of an electric motor with a current and speed controller, as well with a more detailed model of a gearbox.</p><h2 id=".6-Arrays"><a class="docs-heading-anchor" href="#.6-Arrays">2.6 Arrays</a><a id=".6-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#.6-Arrays" title="Permalink"></a></h2><p>Model parameters and variables can be arrays. For example a linear state space system</p><p class="math-container">\[\begin{aligned}
\frac{d\boldsymbol{x}}{dt} &amp;= \boldsymbol{A} \cdot \boldsymbol{x} + \boldsymbol{B} \cdot \boldsymbol{u}\\
            \boldsymbol{y} &amp;= \boldsymbol{C} \cdot \boldsymbol{x} + \boldsymbol{D} \cdot \boldsymbol{u}
\end{aligned}\]</p><p>can be defined as:</p><pre><code class="language-julia hljs">StateSpace = Model(
    A = fill(0.0, 0, 0),
    B = fill(0.0, 0, 0),
    C = fill(0.0, 0, 0),
    D = fill(0.0, 0, 0),
    u = input,
    y = output,
    x = Var(init = zeros(0)),
    equations = :[
        der(x) = A*x + B*u
             y = C*x + D*u
    ]
)</code></pre><p>and used as:</p><pre><code class="language-julia hljs">SecondOrder = Model(
    w = 20.0,
    D =  0.1,
    k =  2.0,
    sys = StateSpace | Map(A = :([  0        1;
                                 -w^2  -2*D*w]),
                           B = :([0; w^2;;]),    # Julia 1.7: Trailing &quot;;;&quot; defines a column matrix
                           C = :([k 0]),
                           D = :(zeros(1,1)),
                           x = Var(init = zeros(2)) ),
    equations = :[sys.u = [1.0]]
)</code></pre><p>Variables <code>sys.u</code> and <code>sys.y</code> are vectors with one element each.</p><p>Note, <code>[0; w^2]</code> is a vector in Julia and not a column matrix. In order that <code>B</code> is defined as column matrix, the Julia 1.7 feature is used to append two semikolons, that is, <code>[0; w^2;;]</code></p><p>Array equations remain array equations during symbolic transformation and in the generated code, so the code is both compact and efficient. In order that this is reasonably possible, the definition of an array cannot be split in different statements:</p><pre><code class="language-julia hljs">equations = :[             # error, vector v is not defined as one symbol
    m1*der(v[1]) = 2.0
    m2*der(v[2]) = 3.0
]</code></pre><p>If scalar equations are needed in which arrays are used, then the arrays have to be first defined and then elements can be used.</p><pre><code class="language-julia hljs">v = Var(init=zeros(2)),
equations = :[
    a = der(v)
    a1 = a[1]
    a2 = a[2]
    m1*a1 = 2.0
    m2*a2 = 3.0
]</code></pre><p>When the init or start value of an array variable is defined as a <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays</a> array, then the value of this array remains to be a StaticArrays variable also in the generated code. The benefit is that array operations are more efficient:</p><pre><code class="language-julia hljs">using StaticArrays
TestArray1 = Model
    v = Var(init=SVector{3,Float64}(1.0, 2.0, 3.0)),
    equations = :[der(v) = -v]
)
testArray1 =  @instantiateModel(TestArray1, logCode=true)</code></pre><p>Note, the generated code is shown in the REPL if <code>logCode=true</code> is defined:</p><pre><code class="language-julia hljs">function getDerivatives(_x, _m::Modia.SimulationModel{_FloatType,_TimeType} ...
    ...
    v::ModiaBase.SVector{3,_FloatType} = ModiaBase.SVector{3,_FloatType}(_x[1:3])
    var&quot;der(v)&quot; = -v
    ...</code></pre><p>The sizes of StaticArrays variables cannot be changed, after <code>@instantiatedModel</code> was called. However, the sizes of standard array variables can be changed with keyword argument <code>merge</code> in <code>simulate!</code> (so no re-generation and re-compilation of the code is needed):</p><pre><code class="language-julia hljs">TestArray2 = Model(
    v = Var(init=[1.0, 2.0, 3.0]),   # length(v) = 3
    equations = :[der(v) = -v]
)
testArray2 = @instantiateModel(TestArray2)
simulate!(testArray2, stopTime=2.0, merge=Map(v = [4.0, 3.0, 2.0, 1.0]))   # length(v) = 4
plot(testArray2, &quot;v&quot;, figure=5)</code></pre><h2 id=".7-Model-libraries"><a class="docs-heading-anchor" href="#.7-Model-libraries">2.7 Model libraries</a><a id=".7-Model-libraries-1"></a><a class="docs-heading-anchor-permalink" href="#.7-Model-libraries" title="Permalink"></a></h2><p>Modia provides a small set of pre-defined model components in directory <code>Modia.modelsPath</code>:</p><ul><li><code>AllModels.jl</code> - Include all model libraries</li><li><code>Blocks.jl</code> - Input/output control blocks</li><li><code>Electric.jl</code> - Electric component models</li><li><code>HeatTransfer.jl</code> - 1D heat transfer component models</li><li><code>Rotational.jl</code> - 1D rotational, mechanical component models</li><li><code>Translational.jl</code> - 1D translational, mechanical component models</li><li><a href="../Functions.html#PathPlanning">PathPlanning</a> - Defining reference trajectories and access them.</li></ul><p>The desired libraries must be explicitly included with the help of utility path variable <code>Modia.modelsPath</code>. For example, the circuit of section <a href="Modeling.html#.5.5-Connected-models">2.5.5 Connected models</a> is constructed with these libraries in the following way:</p><pre><code class="language-julia hljs">using Modia
include(&quot;$(Modia.modelsPath)/Electric.jl&quot;)

FilterCircuit = Model(
    R = Modia.Resistor  | Map(R=0.5u&quot;Ω&quot;),
    C = Modia.Capacitor | Map(C=2.0u&quot;F&quot;, v=Var(init=0.1u&quot;V&quot;)),
    V = Modia.ConstantVoltage | Map(V=10.0u&quot;V&quot;),
    ground = Modia.Ground,
    connect = :[
      (V.p, R.p)
      (R.n, C.p)
      (C.n, V.n, ground.p)
    ]
)

filterCircuit = @instantiateModel(FilterCircuit)
simulate!(filterCircuit, Tsit5(), stopTime=10.0)
@usingPlotPackage
plot(filterCircuit, [&quot;C.v&quot;, &quot;C.i&quot;], figure=3)</code></pre><p>It is planned to support a much larger set of predefined model components in the future.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="GettingStarted.html">« 1 Getting Started</a><a class="docs-footer-nextpage" href="Simulation.html">3 Simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Tuesday 5 July 2022 12:31">Tuesday 5 July 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
