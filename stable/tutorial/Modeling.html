<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2 Modeling · Modia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Modia</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Modia Tutorial</span><ul><li><a class="tocitem" href="GettingStarted.html">1 Getting started</a></li><li class="is-active"><a class="tocitem" href="Modeling.html">2 Modeling</a><ul class="internal"><li><a class="tocitem" href="#.1-Equation-oriented-models"><span>2.1 Equation oriented models</span></a></li><li><a class="tocitem" href="#.2-Merging-models"><span>2.2 Merging models</span></a></li><li><a class="tocitem" href="#.3-Functions-and-tables"><span>2.3 Functions and tables</span></a></li><li><a class="tocitem" href="#.4-Hierarchical-modeling"><span>2.4 Hierarchical modeling</span></a></li><li><a class="tocitem" href="#.5-Physically-oriented-modeling"><span>2.5 Physically oriented modeling</span></a></li><li><a class="tocitem" href="#.6-Arrays"><span>2.6 Arrays</span></a></li><li><a class="tocitem" href="#.7-Model-libraries"><span>2.7 Model libraries</span></a></li></ul></li><li><a class="tocitem" href="Simulation.html">3 Simulation</a></li><li><a class="tocitem" href="FloatingPointTypes.html">4 Floating point types</a></li><li><a class="tocitem" href="Appendix.html">Appendix A</a></li></ul></li><li><a class="tocitem" href="../Functions.html">Functions</a></li><li><a class="tocitem" href="../Internal.html">Internal</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modia Tutorial</a></li><li class="is-active"><a href="Modeling.html">2 Modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Modeling.html">2 Modeling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ModiaSim/Modia.jl/blob/master/docs/src/tutorial/Modeling.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">2 Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h1><h2 id=".1-Equation-oriented-models"><a class="docs-heading-anchor" href="#.1-Equation-oriented-models">2.1 Equation oriented models</a><a id=".1-Equation-oriented-models-1"></a><a class="docs-heading-anchor-permalink" href="#.1-Equation-oriented-models" title="Permalink"></a></h2><p>A low pass filter block with input <code>u</code> and output <code>y</code></p><p class="math-container">\[\begin{aligned}
T \cdot \frac{dx}{dt} + x &amp;= u\\
     y &amp;= x \\
x(t_0) &amp;= 0
\end{aligned}\]</p><p>can be defined as:</p><pre><code class="language-julia">    using Modia

    LowPassFilter = Model(
        T = 0.2,
        u = input,
        y = output | Var(:x),
        x = Var(init=0),
        equation = :[T * der(x) + x = u],
    )</code></pre><p>The symbols <code>input</code> and <code>output</code> refer to predefined variable constructors to define the input and output variables. If an equation has just a unique variable in the left hand side, <code>y</code>, the right hand side can be given as a quoted expression in a Var-constructor <code>Var(:x)</code> after the <code>output</code> constructor combined with the merge operator, <code>|</code>, see below.</p><h2 id=".2-Merging-models"><a class="docs-heading-anchor" href="#.2-Merging-models">2.2 Merging models</a><a id=".2-Merging-models-1"></a><a class="docs-heading-anchor-permalink" href="#.2-Merging-models" title="Permalink"></a></h2><p>It is possible to combine models by merging. If we want to change the model to become a highpass filter, an alternative output equation</p><p class="math-container">\[y = -x + u\]</p><p>is defined in an anonymous model <code>Model( y = :(-x + u) )</code>. This anonymous model is merged with <code>LowPassFilter</code> using the merge operator <code>|</code>:</p><pre><code class="language-julia">HighPassFilter = LowPassFilter | Model( y = Var(:(-x + u) ) )</code></pre><p>The merging implies that the <code>output</code> property of <code>y</code> is kept, but the binding expression is changed from <code>:x</code> to <code>:(-x + u)</code>.</p><p>In general, recursive merging is desired and Modia provides a <code>mergeModels</code> function for that (see appendix <a href="Appendix.html#A.3-MergeModels-algorithm">A.3 MergeModels algorithm</a>). This function is invoked as a binary operator <code>|</code> (also used for merge in Python). Note, that the order of the arguments/operands are important.</p><p>Generalizing the block to have two outputs for both low and high pass filtering would be done as follows:</p><pre><code class="language-julia">LowAndHighPassFilter = LowPassFilter | Model(
        y = nothing,
        low = output | Var(:x),
        high = output | Var(:(-x + u)),
    )</code></pre><p>The equation for <code>y</code> is removed by &quot;assigning&quot; <code>nothing</code> and two variables are defined and declared as outputs.</p><p>Model <code>LowAndHighPassFilter</code> represents the following equations:</p><p class="math-container">\[\begin{aligned}
T \cdot \frac{dx}{dt} + x &amp;= u\\
     low &amp;= x \\
    high &amp;= -x + u \\
x(t_0) &amp;= 0
\end{aligned}\]</p><p>By turning on logging of merging <code>setLogMerge(true)</code>, the translator gives the log:</p><pre><code class="language-julia">Adding: value = :(x)
Adding: value = :(-x + u)
Deleting: y
Adding: low = Var(
      output = true,
      value = :(x),
    ),
Adding: high = Var(
      output = true,
      value = :(-x + u),
    ),</code></pre><p>The resulting model is pretty printed by calling <code>@showModel LowAndHighPassFilter</code>:</p><pre><code class="language-julia">LowAndHighPassFilter = Model(
  T = 0.2,
  u = Var(
    input = true,
  ),
  x = Var(
    init = 0.0 V,
  ),
  equations = :([T * der(x) + x = u]),
  low = Var(
    output = true,
    value = :(x),
  ),
  high = Var(
    output = true,
    value = :(-x + u),
  ),
),</code></pre><h2 id=".3-Functions-and-tables"><a class="docs-heading-anchor" href="#.3-Functions-and-tables">2.3 Functions and tables</a><a id=".3-Functions-and-tables-1"></a><a class="docs-heading-anchor-permalink" href="#.3-Functions-and-tables" title="Permalink"></a></h2><p>In order to test an input/output block as defined in the previous section, an input needs to be defined. This can be made by adding an equation for <code>u</code>. Assume we want <code>u</code> to be sinousoidial with an increasing frequency:</p><pre><code class="language-julia">TestLowAndHighPassFilter = LowAndHighPassFilter | Model(
        u = :(sin( (time+1u&quot;s&quot;)*u&quot;1/s/s&quot; * time)*u&quot;V&quot;),
        x = Var(init=0.2u&quot;V&quot;)
    )</code></pre><p><code>time</code> is a reserved name for the independent variable. It has unit <code>s</code> for seconds. The Julia package <a href="https://painterqubits.github.io/Unitful.jl/stable/">Unitful</a> provides a means for defining units and managing unit inference. It need not be explicitly defined, because its symbols are exported by <code>using Modia</code>. Definition of units is done with a string macro <code>u&quot;...&quot;</code>. In this case, the input signal was given unit Volt. The state x must then also have consistent unit, that is Volt. If the model equations contain systems of simultaneous equations, then approximate guess values, optionally with units, must be given <code>start</code>: <code>i = Var(start=0.0u&quot;A&quot;)</code>.</p><p>The input signal can also be defined by interpolation in a table:</p><pre><code class="language-julia">using Interpolations

table = CubicSplineInterpolation(0:0.5:2.0, [0.0, 0.7, 2.0, 1.8, 1.2])
TestLowAndHighPassFilter2 = TestLowAndHighPassFilter | Map(u = :(table(time*u&quot;1/s&quot;)*u&quot;V&quot;))</code></pre><p>A function cannot return more as one variable and a function cannot modify one of its arguments:</p><pre><code class="language-none">equations = :[
    (y1, y1) = fc1(u1,u2)      # Error: Two return arguments
    fc2!(u,y)                  # Error: Not known that fc2! computes y
    println(&quot;This is a test&quot;)  # Fine
]</code></pre><p>The first issue can be fixed by rewriting the function call:</p><pre><code class="language-none">equations = :[
    v  = fc1(u1,u2)
    y1 = v[1]
    y2 = v[2]
]</code></pre><h2 id=".4-Hierarchical-modeling"><a class="docs-heading-anchor" href="#.4-Hierarchical-modeling">2.4 Hierarchical modeling</a><a id=".4-Hierarchical-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#.4-Hierarchical-modeling" title="Permalink"></a></h2><p>Sofar, the composition of models have resulted in named tuples with values being numeric values or quoted expressions. Hierarchical models are obtained if the values themself are named tuples. A model with two filters can, for example, be defined as follows:</p><pre><code class="language-julia">TwoFilters = (
    high = HighPassFilter,
    low = LowPassFilter,
)</code></pre><p>Note, that the previous definitions of HighPassFilter and LowPassFilter was used instead of making the defintions inline.</p><p>A band pass filter is a series connection of a high pass filter and a low pass filter and can be described as:</p><pre><code class="language-julia">BandPassFilter = (
    u = input,
    y = output,
    high = HighPassFilter | Map(T=0.5, x=Var(init=0.1u&quot;V&quot;)),
    low = LowPassFilter | Map(x=Var(init=0.2u&quot;V&quot;)),
    equations = :[
        high.u = u,
        low.u = high.y,
        y = low.y]
)</code></pre><p>A new input has been defined which is propagated to <code>high.u</code>. The series connection itself is obtained by the equation <code>low.u = high.y</code>. Note, that dot-notation is allowed in equations.</p><p>The input and output for the BandPassFilter when using the same input definition as for the TestLowPassFilter</p><pre><code class="language-julia">TestBandPassFilter = BandPassFilter | Map(
        u = :(sin( (time+1u&quot;s&quot;)*u&quot;1/s/s&quot; * time)*u&quot;V&quot;)
    )
bandPassFilter = @instantiateModel(TestBandPassFilter)
simulate!(bandPassFilter, Tsit5(), stopTime = 50u&quot;s&quot;)
plot(bandPassFilter, [&quot;u&quot;, &quot;y&quot;], figure=2)</code></pre><p>is shown below:</p><p><img src="../../resources/images/BandPassFilterPlot.png" alt="Band Pass Filter Plot"/></p><h2 id=".5-Physically-oriented-modeling"><a class="docs-heading-anchor" href="#.5-Physically-oriented-modeling">2.5 Physically oriented modeling</a><a id=".5-Physically-oriented-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#.5-Physically-oriented-modeling" title="Permalink"></a></h2><p>Sofar, only signal flow modeling has been used, i.e. input/output blocks coupled with equations between outputs and inputs. For object oriented modeling more high level constructs are neccessary. Coupling is then acausal and involves potentials such as electric potential, positions, pressure, etc. and flows such as electric current, forces and torques and mass flow rate.</p><h3 id=".5.1-Connectors"><a class="docs-heading-anchor" href="#.5.1-Connectors">2.5.1 Connectors</a><a id=".5.1-Connectors-1"></a><a class="docs-heading-anchor-permalink" href="#.5.1-Connectors" title="Permalink"></a></h3><p>Models which contain any flow variable, i.e. a variable having an attribute <code>flow=true</code>, are considered connectors. Connectors must have equal number of flow and potential variables, i.e. variables having an attribute <code>potential=true</code>, and have matching array sizes. Connectors may not have any equations. An example of an electrical connector with potential (in Volt) and current (in Ampere) is shown below.</p><pre><code class="language-julia">Pin = Model( v = potential, i = flow )</code></pre><p><code>potential</code> is a shortcut for <code>Var(potential=true)</code> and similarly for <code>flow</code>.</p><h3 id=".5.2-Components"><a class="docs-heading-anchor" href="#.5.2-Components">2.5.2 Components</a><a id=".5.2-Components-1"></a><a class="docs-heading-anchor-permalink" href="#.5.2-Components" title="Permalink"></a></h3><p>Components are declared in a similar ways as blocks. However, the interfaces between components are defined using connector instances.</p><p>An electrical resistor can be descibed as follows:</p><pre><code class="language-julia">Resistor = Model(
    R = 1.0u&quot;Ω&quot;,
    p = Pin,
    n = Pin,
    equations = :[
        0 = p.i + n.i
        v = p.v - n.v
        i = p.i
        R*i = v ]
    )</code></pre><h3 id=".5.3-Inheritance"><a class="docs-heading-anchor" href="#.5.3-Inheritance">2.5.3 Inheritance</a><a id=".5.3-Inheritance-1"></a><a class="docs-heading-anchor-permalink" href="#.5.3-Inheritance" title="Permalink"></a></h3><p>Various physical components sometimes share common properties. One mechanism to handle this is to use inheritance. In Modia, <strong>merging</strong> is used.</p><p>Electrical components such as resistors, capacitors and inductors are categorized as oneports which have two pins. Common properties are: constraint on currents at the pins and definitions of voltage over the component and current through the component.</p><pre><code class="language-julia">OnePort = Model(
    p = Pin,
    n = Pin,
    partialEquations = :[
        0 = p.i + n.i
        v = p.v - n.v
        i = p.i ] )</code></pre><p>Having such a OnePort definition makes it convenient to define electrical component models by merging OnePort with specific parameter definitions with default values and equations:</p><pre><code class="language-julia">Resistor = OnePort | Model( R = 1.0u&quot;Ω&quot;, equation = :[ R*i = v ], )

Capacitor = OnePort | Model( C = 1.0u&quot;F&quot;, v=Map(init=0.0u&quot;V&quot;), equation = :[ C*der(v) = i ] )

Inductor = OnePort | Model( L = 1.0u&quot;H&quot;, i=Map(init=0.0u&quot;A&quot;), equation = :[ L*der(i) = v ] )

ConstantVoltage = OnePort | Model( V = 1.0u&quot;V&quot;, equation = :[ v = V ] )</code></pre><p>The merged <code>Resistor</code> is shown below:</p><pre><code class="language-julia">Resistor = Model(
  p = Model(
    v = Var(
      potential = true,
    ),
    i = Var(
      flow = true,
    ),
  ),
  n = Model(
    v = Var(
      potential = true,
    ),
    i = Var(
      flow = true,
    ),
  ),
  partialEquations = :([v = p.v - n.v; 0 = p.i + n.i; i = p.i]),
  R = 1.0 Ω,
  equations = :([R * i = v]),
),</code></pre><h3 id=".5.4-Connections"><a class="docs-heading-anchor" href="#.5.4-Connections">2.5.4 Connections</a><a id=".5.4-Connections-1"></a><a class="docs-heading-anchor-permalink" href="#.5.4-Connections" title="Permalink"></a></h3><p>Connections are described as an array of tuples listing the connectors that are connected:</p><pre><code class="language-julia">    ( &lt;connect reference 1&gt;, &lt;connect reference 2&gt;, ... )</code></pre><p>A connect reference has either the form &#39;connect instance name&#39; or &#39;component instance name&#39;.&#39;connect instance name&#39; with &#39;connect instance name&#39; being either a connector instance, input or output variable.</p><p>Examples</p><pre><code class="language-julia">    connect = :[
      (V.p, R1.p)
      (R1.n, p)
      (C1.n, V.n, R2.p)
      ...
    ]</code></pre><p>For connectors, all the potentials of the connectors in the same connect tuple are set equal and the sum of all incoming flows to the model are set equal to the sum of the flows into sub-components.</p><h3 id=".5.5-Connected-models"><a class="docs-heading-anchor" href="#.5.5-Connected-models">2.5.5 Connected models</a><a id=".5.5-Connected-models-1"></a><a class="docs-heading-anchor-permalink" href="#.5.5-Connected-models" title="Permalink"></a></h3><p>Having the above electrical component models, enables defining a filter</p><p><img src="../../resources/images/Filter.png" alt="Filter Circuit"/></p><p>by instanciating components, setting parameters and defining connections.</p><pre><code class="language-julia">Filter = (
    R = Resistor | Map(R=0.5u&quot;Ω&quot;),
    C = Capacitor | Map(C=2.0u&quot;F&quot;),
    V = ConstantVoltage | Map(V=10.0u&quot;V&quot;),
    connect = :[
      (V.p, R.p)
      (R.n, C.p)
      (C.n, V.n)
    ]
)</code></pre><p>The connect tuples are translated to:</p><pre><code class="language-julia">  V.p.v = R.p.v
  0 = V.p.i + R.p.i
  R.n.v = C.p.v
  0 = R.n.i + C.p.i
  C.n.v = V.n.v
  0 = C.n.i + V.n.i</code></pre><h3 id=".5.6-Parameter-propagation"><a class="docs-heading-anchor" href="#.5.6-Parameter-propagation">2.5.6 Parameter propagation</a><a id=".5.6-Parameter-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#.5.6-Parameter-propagation" title="Permalink"></a></h3><p>Hierarchical modification of parameters is powerful but sometimes a bit inconvenient. It is also possible to propagate parameters intoduced on a high level down in the hierarchy. The following Filter model defines three parameters, <code>r</code>, <code>c</code> and <code>v</code>. The <code>r</code> parameter is used to set the resistance of the resistor R: <code>Map(R=:r)</code>.</p><pre><code class="language-julia">Filter2 = Model(
    r = 2.0u&quot;Ω&quot;,
    c = 1.0u&quot;F&quot;,
    v = 10u&quot;V&quot;,
    R = Resistor | Map(R=:r),
    C = Capacitor | Map(C=:c),
    V = ConstantVoltage | Map(V=:v),
    connect = :[
      (V.p, R.p)
      (R.n, C.p)
      (C.n, V.n)
    ]
)</code></pre><p>Two separate filters can then be defined with:</p><pre><code class="language-julia">TwoFilters = Model( f1 = Filter | Map( r = 10.0, c = 2.0), f2 = Filter )</code></pre><h3 id=".5.7-Redeclarations"><a class="docs-heading-anchor" href="#.5.7-Redeclarations">2.5.7 Redeclarations</a><a id=".5.7-Redeclarations-1"></a><a class="docs-heading-anchor-permalink" href="#.5.7-Redeclarations" title="Permalink"></a></h3><p>It is possible to reuse a particular model topology by redeclaring the model of particular components. For example, changing the filter <code>f1</code> to a voltage divider by changing C from a Capacitor to a Resistor. A predefined model <code>Redeclare</code> is used for this purpose.</p><pre><code class="language-julia">VoltageDividerAndFilter = TwoFilters | Map(f1 = Map(C = Redeclare | Resistor | Map(R = 20.0)))</code></pre><p>By using <code>Redeclare</code>, a new model based on a Resistor is used for <code>C</code> and the usual merge semantics with the previously defined model of <code>C</code> is not used.</p><p>The above examples are available in file <code>FilterCircuit.jl</code>.</p><h3 id=".5.8-Drive-train-example"><a class="docs-heading-anchor" href="#.5.8-Drive-train-example">2.5.8 Drive train example</a><a id=".5.8-Drive-train-example-1"></a><a class="docs-heading-anchor-permalink" href="#.5.8-Drive-train-example" title="Permalink"></a></h3><p>A larger example that utilizes most of the previously described features of Modia is available as <code>$(Modia.path)/examples/ServoSystem.jl</code>. This is a textual (Modia) representation of a Modelica model</p><p><img src="../../resources/images/ServoSystem.png" alt="ServoSystem"/></p><p>and demonstrates how to build up a hierarchical, multi-domain model consisting of a servo-system with a load, where the servo-system consists of an electric motor with a current and speed controller, as well with a more detailed model of a gearbox.</p><h2 id=".6-Arrays"><a class="docs-heading-anchor" href="#.6-Arrays">2.6 Arrays</a><a id=".6-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#.6-Arrays" title="Permalink"></a></h2><p>Model parameters and variables can be arrays. For example a linear state space system with <span>$\boldsymbol{x}(t) \in \R^{n_x}, \boldsymbol{u}(t) \in \R^{n_u}, \boldsymbol{y}(t) \in \R^{n_y},  \boldsymbol{A} \in \R^{n_x \times n_x}, \boldsymbol{B} \in \R^{n_x \times n_u},  \boldsymbol{C} \in \R^{n_y \times n_x}, \boldsymbol{D} \in \R^{n_y \times n_u}$</span></p><p class="math-container">\[\begin{aligned}
\frac{d\boldsymbol{x}}{dt} &amp;= \boldsymbol{A} \cdot \boldsymbol{x} + \boldsymbol{B} \cdot \boldsymbol{u}\\
            \boldsymbol{y} &amp;= \boldsymbol{C} \cdot \boldsymbol{x} + \boldsymbol{D} \cdot \boldsymbol{u}
\end{aligned}\]</p><p>can be defined as:</p><pre><code class="language-julia">StateSpace = Model(
    A = fill(0.0,0,0),
    B = fill(0.0,0,0),
    C = fill(0.0,0,0),
    D = fill(0.0,0,0),
    u = input,
    y = output,
    x = Var(init = zeros(0)),
    equations = :[
        der(x) = A*x + B*u
             y = C*x + D*u
    ]
)</code></pre><p>and used as:</p><pre><code class="language-julia">col(args...) = hvcat(1, args...)  # Construct a column matrix from a vector

SecondOrder = Model(
    w = 20.0,
    D =  0.1,
    k =  2.0,
    sys = StateSpace | Map(A = :([  0        1;
                                 -w^2  -2*D*w]),
                           B = :(col([0; w^2])),
                           C = :([k 0]),
                           D = :(zeros(1,1)),
                           x = Var(init = zeros(2)) ),
    equations = :[sys.u = [1.0]]
)</code></pre><p>Variables <code>sys.u</code> and <code>sys.y</code> are vectors with one element each.</p><p>Note, <code>[0; w^2]</code> is a vector in Julia and not a column matrix (see the discussion <a href="https://discourse.julialang.org/t/construct-a-2-d-column-array/30617">here</a>). In order that <code>B</code> is defined as column matrix, the function <code>col(..)</code> is used.</p><p>Array equations remain array equations during symbolic transformation and in the generated code, so the code is both compact and efficient. In order that this is reasonably possible, the definition of an array cannot be split in different statements:</p><pre><code class="language-julia">equations = :[             # error, vector v is not defined as one symbol
    m1*der(v[1]) = 2.0
    m2*der(v[2]) = 3.0
]</code></pre><p>If scalar equations are needed in which arrays are used, then the arrays have to be first defined and then elements can be used.</p><pre><code class="language-julia">v = Var(init=zeros(2)),
equations = :[
    a = der(v)
    a1 = a[1]
    a2 = a[2]
    m1*a1 = 2.0
    m2*a2 = 3.0
]</code></pre><h2 id=".7-Model-libraries"><a class="docs-heading-anchor" href="#.7-Model-libraries">2.7 Model libraries</a><a id=".7-Model-libraries-1"></a><a class="docs-heading-anchor-permalink" href="#.7-Model-libraries" title="Permalink"></a></h2><p>Modia provides a small set of pre-defined model components in directory <code>$(Modia.path)/models</code>:</p><ul><li><code>AllModels.jl</code> - Include all model libraries</li><li><code>Blocks.jl</code> - Input/output control blocks</li><li><code>ELectric.jl</code> - Electric component models</li><li><code>HeatTransfer.jl</code> - 1D heat transfer component models</li><li><code>Rotational.jl</code> - 1D rotational, mechanical component models</li></ul><p>These models are included in package <code>Modia</code>, but are not exported, so must be access with `Modia.xxx&quot;.</p><p>The circuit of section <a href="Modeling.html#.5.5-Connected-models">2.5.5 Connected models</a> can be for example constructed with these libraries in the following way:</p><pre><code class="language-julia">using Modia, ModiaPlot

FilterCircuit = Model(
    R = Modia.Resistor  | Map(R=0.5u&quot;Ω&quot;),
    C = Modia.Capacitor | Map(C=2.0u&quot;F&quot;, v=Var(init=0.1u&quot;V&quot;)),
    V = Modia.ConstantVoltage | Map(V=10.0u&quot;V&quot;),
    ground = Modia.Ground,
    connect = :[
      (V.p, R.p)
      (R.n, C.p)
      (C.n, V.n, ground.p)
    ]
)

filterCircuit = @instantiateModel(FilterCircuit)
simulate!(filterCircuit, Tsit5(), stopTime=10.0)
plot(filterCircuit, [&quot;C.v&quot;, &quot;C.i&quot;], figure=3)</code></pre><p>It is planned to support a much larger set of predefined model components in the future.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="GettingStarted.html">« 1 Getting started</a><a class="docs-footer-nextpage" href="Simulation.html">3 Simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 25 April 2021 13:10">Sunday 25 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
