<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>3 Simulation · Modia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Modia</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="Tutorial.html">Modia Tutorial</a></li><li><a class="tocitem" href="GettingStarted.html">1 Getting Started</a></li><li><a class="tocitem" href="Modeling.html">2 Modeling</a></li><li class="is-active"><a class="tocitem" href="Simulation.html">3 Simulation</a><ul class="internal"><li><a class="tocitem" href="#.1-Instantiating"><span>3.1 Instantiating</span></a></li><li><a class="tocitem" href="#.2-Simulating"><span>3.2 Simulating</span></a></li><li><a class="tocitem" href="#.4-Plotting"><span>3.4 Plotting</span></a></li><li><a class="tocitem" href="#.5-State-selection-(DAEs)"><span>3.5 State selection (DAEs)</span></a></li></ul></li><li><a class="tocitem" href="FloatingPointTypes.html">4 Floating Point Types</a></li><li><a class="tocitem" href="Appendix.html">Appendix A</a></li></ul></li><li><a class="tocitem" href="../Functions.html">Functions</a></li><li><a class="tocitem" href="../Internal.html">Internal</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href="Simulation.html">3 Simulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Simulation.html">3 Simulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ModiaSim/Modia.jl/blob/main/docs/src/tutorial/Simulation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">3 Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h1><p>A particular model is instantiated, simulated and results plotted with the commands:</p><pre><code class="language-julia hljs">using Modia
@usingPlotPackage

filter = @instantiateModel(Filter)
simulate!(filter, stopTime=10.0)
plot(filter, &quot;y&quot;, figure=1)</code></pre><h2 id=".1-Instantiating"><a class="docs-heading-anchor" href="#.1-Instantiating">3.1 Instantiating</a><a id=".1-Instantiating-1"></a><a class="docs-heading-anchor-permalink" href="#.1-Instantiating" title="Permalink"></a></h2><p>The <code>@instantiateModel</code> macro takes additional arguments:</p><pre><code class="language-julia hljs">modelInstance = @instantiateModel(model; FloatType = Float64, aliasReduction=true, unitless=false,
        evaluateParameters=false, log=false, logModel=false, logDetails=false, logStateSelection=false,
        logCode=false,logExecution=logExecution, logCalculations=logCalculations, logTiming=false)</code></pre><p>The macro performs structural and symbolic transformations, generates a function for calculation of derivatives suitable for use with <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> and returns <a href="../Internal.html#Modia.SimulationModel"><code>SimulationModel</code></a> that can be used in other functions, for example to simulate or plot results. Explanation of the arguments:</p><ul><li><code>model</code>: model (declarations and equations)</li><li><code>FloatType</code>: Variable type for floating point numbers, for example: Float64, Measurements{Float64}, StaticParticles{Float64,100}, Particles{Float64,2000}</li><li><code>aliasReduction</code>: Perform alias elimination and remove singularities</li><li><code>unitless</code>: Remove units (useful while debugging models and needed for MonteCarloMeasurements)</li><li><code>evaluateParameters</code>: Use evaluated parameters in the generated code.</li><li><code>log</code>: Log the different phases of translation</li><li><code>logModel</code>: Log the variables and equations of the model</li><li><code>logDetails</code>: Log internal data during the different phases of translation</li><li><code>logStateSelection</code>: Log details during state selection</li><li><code>logCode</code>: Log the generated code</li><li><code>logExecution</code>: Log the execution of the generated code (useful for timing compilation)</li><li><code>logCalculations</code>: Log the calculations of the generated code (useful for finding unit bugs)</li><li><code>logTiming</code>: Log timing of different phases</li><li><code>return modelInstance prepared for simulation</code></li></ul><h2 id=".2-Simulating"><a class="docs-heading-anchor" href="#.2-Simulating">3.2 Simulating</a><a id=".2-Simulating-1"></a><a class="docs-heading-anchor-permalink" href="#.2-Simulating" title="Permalink"></a></h2><p>The <a href="../Functions.html#Modia.simulate!"><code>simulate!</code></a> function performs one simulation with <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> using by default integrator <code>Sundials.CVODE_BDF()</code>, provided instantiatedModel has <code>FloatType = Float64</code>. Otherwise, a default algorithm will be chosen from DifferentialEquations (for details see <a href="https://arxiv.org/pdf/1807.06430">https://arxiv.org/pdf/1807.06430</a>, Figure 3). The reason to choose <code>CVODE_BDF</code> as default integrator is that it is a very robust integrator and also usually very efficient for larger models, provided there are no undamped vibrations. It is also possible to specify the integrator as second argument of <code>simulate!</code>:</p><pre><code class="language-julia hljs">using Modia
@usingPlotPackage

filter = @instantiateModel(Filter)
sol = simulate!(filter, Tsit5(), stopTime=10.0, merge=Map(T=0.5, x=0.8))
plot(filter, [&quot;y&quot;, &quot;x&quot;], figure=1)</code></pre><p>Integrator <code>DifferentialEquations.Tsit5</code> is an <a href="https://www.sciencedirect.com/science/article/pii/S0898122111004706">adaptive Runge-Kutta method of order 5/4 from Tsitouras</a>. There are &gt; 100 ODE integrators provided. For details, see <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/">here</a>.</p><p>Parameters and init/start values can be changed with the <code>merge</code> keyword. The effect is the same, as if the filter would have been instantiated with:</p><pre><code class="language-julia hljs">filter = @instantiateModel(Filter | Map(T=0.5, x=Var(init=0.8))</code></pre><p>Note, with the <code>merge</code> keyword in simulate!, init/start values are directly given as a value (<code>x = 0.8</code>) and are not defined with <code>Var(..)</code>.</p><p>Function <code>simulate!</code> returns <code>sol</code> which is the value that is returned by function <a href="https://diffeq.sciml.ai/stable/features/ensemble/#Solving-the-Problem">DifferentialEquations.solve</a>. Functions of <code>DifferentialEquations</code> that operate on this return argument can therefore also be used on the return argument <code>sol</code> of <code>simulate!</code>.</p><h2 id=".4-Plotting"><a class="docs-heading-anchor" href="#.4-Plotting">3.4 Plotting</a><a id=".4-Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#.4-Plotting" title="Permalink"></a></h2><p>A short overview of the most important plot commands is given in section <a href="../Functions.html#Results-and-Plotting">Results and Plotting</a></p><h2 id=".5-State-selection-(DAEs)"><a class="docs-heading-anchor" href="#.5-State-selection-(DAEs)">3.5 State selection (DAEs)</a><a id=".5-State-selection-(DAEs)-1"></a><a class="docs-heading-anchor-permalink" href="#.5-State-selection-(DAEs)" title="Permalink"></a></h2><p>Modia has a sophisticated symbolic engine to transform high index DAEs (Differential Algebraic Equations) automatically to ODEs (Ordinary Differential Equations in state space form). During the transformation, equations might be analytically differentiated and code might be generated to solve linear equation systems numerically during simulation. The current engine <strong>cannot</strong> transform a DAE to ODE form, if the <strong>DAE contains nonlinear algebraic equations</strong>. There is an (internal) prototype available to transform nearly any DAE system to a special index 1 DAE system that can be solved with standard DAE integrators. After a clean-up phase, this engine will be made publicly available at some time in the future. Some of the algorithms used in Modia are described in <a href="https://modelica.org/events/modelica2017/proceedings/html/submissions/ecp17132565_OtterElmqvist.pdf">Otter and Elmqvist (2017)</a>. Some algorithms are not yet published.</p><p>Usually, the symbolic engine is only visible to the modeler, when the model has errors, or when the number of ODE states is less than the number of DAE states. The latter case is discussed in this section.</p><p>The following object diagram shows two rotational inertias that are connected by an ideal gear. One inertia is actuated with a sinusoidal torque:</p><p><img src="../../resources/images/TwoInertiasAndIdealGear.png" alt="TwoInertiasAndIdealGear"/></p><p>In order to most easily understand the issues, this model is provided in a compact, &quot;flattened&quot; form:</p><pre><code class="language-julia hljs">TwoInertiasAndIdealGearTooManyInits = Model(
    J1    = 50,
    J2    = 100,
    ratio = 2,
    f     = 3, # Hz

    phi1 = Var(init = 0.0), # Absolute angle of inertia1
    w1   = Var(init = 0.0), # Absolute angular velocity of inertia1
    phi2 = Var(init = 0.0), # Absolute angle of inertia2
    w2   = Var(init = 0.0), # Absolute angular velocity of inertia2

    equations = :[
        tau = 2.0*sin(2*3.14*f*time/u&quot;s&quot;)

        # inertia1
        w1 = der(phi1)
        J1*der(w1) = tau - tau1

        # ideal gear
        phi1 = ratio*phi2
        ratio*tau1 = tau2

        # inertia2
        w2 = der(phi2)
        J2*der(w2) = tau2
    ]
)

drive1 = @instantiateModel(TwoInertiasAndIdealGearTooManyInits)
simulate!(drive1, Tsit5(), stopTime = 1.0, logStates=true)
plot(drive1, [(&quot;phi1&quot;, &quot;phi2&quot;), (&quot;w1&quot;, &quot;w2&quot;)])</code></pre><p>The option <code>logStates=true</code> results in the following output:</p><pre><code class="nohighlight hljs">... Simulate model TwoInertiasAndIdealGearTooManyInits

│ # │ state  │ init │ unit │ nominal │
├───┼────────┼──────┼──────┼─────────┤
│ 1 │ phi2   │ 0.0  │      │ NaN     │
│ 2 │ w2     │ 0.0  │      │ NaN     │</code></pre><p>This model translates and simulates without problems.</p><p>Changing the init-value of <code>w2</code> to <code>1.0</code> and re-simulating:</p><pre><code class="language-julia hljs">simulate!(drive1, Tsit5(), stopTime = 1.0, logStates=true, merge = Map(w2=1.0))</code></pre><p>results in the following error:</p><pre><code class="nohighlight hljs">... Simulate model TwoInertiasAndIdealGearTooManyInits

│ # │ state │ init │ unit │ nominal │
├───┼───────┼──────┼──────┼─────────┤
│ 1 │ phi2  │ 0.0  │      │ NaN     │
│ 2 │ w2    │ 1.0  │      │ NaN     │


Error from simulate!:
The following variables are explicitly solved for, have init-values defined
and after initialization the init-values are not respected
(remove the init-values in the model or change them to start-values):

│ # │ name │ beforeInit │ afterInit │
├───┼──────┼────────────┼───────────┤
│ 1 │ w1   │ 0.0        │ 2.0       │</code></pre><p>The issue is the following:</p><p>Every variable that is used in the <code>der</code> operator is a <strong>potential ODE state</strong>. When an <code>init</code> value is defined for such a variable, then Modia either utilizes this initial condition (so the variable has this value after initialization), or an error is triggered, as in the example above.</p><p>The model contains the equation:</p><pre><code class="language-julia hljs">phi1 = ratio*phi2</code></pre><p>So the potential ODE states <code>phi1</code> and <code>phi2</code> are constrained, and only one of them can be selected as ODE state, and the other variable is computed from this equation. Since parameter <code>ratio</code> can be changed before simulation is started, it can be changed also to a value of <code>ratio = 0</code>. Therefore, only when <code>phi2</code> is selected as ODE state, <code>phi1</code> can be uniquely computed from this equation. If <code>phi1</code> would be selected as ODE state, then a division by zero would occur, if <code>ratio = 0</code>, since <code>phi2 = phi1/ratio</code>. For this reason, Modia selects <code>phi2</code> as ODE state. This means the <strong><code>init</code> value of <code>phi1</code> has no effect</strong>. This is uncritical, as long as initialization computes this init value from the constraint equation above, as done in the example above.</p><p>When differentiating the equation above:</p><pre><code class="language-julia hljs">der(phi1) = ratio*der(phi2)  # differentiated constraint equation
       w1 = der(phi1)
       w2 = der(phi2)</code></pre><p>it becomes obvious, that there is also a hidden constraint equation for the potential ODE states <code>w1, w2</code>:</p><pre><code class="language-julia hljs">w1 = ratio*w2  # hidden constraint equation</code></pre><p>Again, Modia selects <code>w2</code> as ODE state, and ignores the <code>init</code> value of <code>w1</code>. In the second simulation, the <code>init</code> value of <code>w1</code> (= 0.0) is no longer consistent to the init value of <code>w2</code> (= 1.0). Therefore, an error occurs.</p><p>The remedy is to remove the <code>init</code> values of <code>phi1, w1</code> from the model:</p><pre><code class="language-julia hljs">drive2 = @instantiateModel(TwoInertiasAndIdealGearTooManyInits |
                                Map(phi1 = Var(init=nothing),
                                    w1   = Var(init=nothing)) )
simulate!(drive2, Tsit5(), stopTime = 1.0, logStates=true, merge = Map(w2=1.0))</code></pre><p>and simulation is successful!</p><p>Modia tries to respect <code>init</code> values during symbolic transformation. In cases as above, this is not possible and the reported issue occurs. In some cases, it might not be obvious, why Modia selects a particular variable as an ODE state. You can get more information by setting <code>logStateSelection=true</code>:</p><pre><code class="language-julia hljs">drive1 = @instantiateModel(TwoInertiasAndIdealGearTooManyInits, logStateSelection=true)</code></pre><p>This results in the following output in the REPL:</p><pre><code class="nohighlight hljs">Instantiating model TwoInertiasAndIdealGearTooManyInits
  in module: Main.Tutorial
  in file: &lt;..&gt;\Modia\examples\Tutorial.jl:196

=== getSortedAndSolvedAST(...) started for TwoInertiasAndIdealGearTooManyInits.

... Equation set 1.1 ..............................
Equations:
   1: tau = 2.0 * sin((2 * 3.14 * f * time) / u&quot;s&quot;)
Unknown variables:
   1: tau
One equation in one unknown variable. Solve the equation:
Julia code:
    tau = 2.0 * sin((2 * 3.14 * _FloatType(_p[:f])::_FloatType * time) / u&quot;s&quot;)

... Equation set 2.1 ..............................
Equations:
   4: phi1 = ratio * phi2
Unknown variables:
   7: phi2
   4: phi1
1 equation(s) in 2 unknown variable(s). Tear the system of equations:
    Unknowns with start or init values: phi2, phi1
    Tearing  variables: phi2
    All solved unknowns are dummy states.
Julia code:
    phi1 = _FloatType(_p[:ratio])::_FloatType * phi2

... Equation set 2.2 ..............................
Equations:
   6: w2 = der(phi2)
   8: der(phi1) = ratio * der(phi2)
   2: w1 = der(phi1)
Unknown variables:
   9: w2
  10: der(phi2)
   3: der(phi1)
   2: w1
3 equation(s) in 4 unknown variable(s). Tear the system of equations:
    Unknowns with start or init values: w2, w1
    Tearing  variables: w2
    All solved unknowns are dummy states.
Julia code:
    var&quot;der(phi2)&quot; = w2
    var&quot;der(phi1)&quot; = _FloatType(_p[:ratio])::_FloatType * var&quot;der(phi2)&quot;
    w1 = var&quot;der(phi1)&quot;

... Equation set 2.3 ..............................
Equations:
   5: ratio * tau1 = tau2
   7: J2 * der(w2) = tau2
  10: der(w2) = der(der(phi2))
  11: der(der(phi1)) = ratio * der(der(phi2))
   9: der(w1) = der(der(phi1))
   3: J1 * der(w1) = tau - tau1
Unknown variables:
   8: tau2
  11: der(w2)
  13: der(der(phi2))
  12: der(der(phi1))
   5: der(w1)
   6: tau1
6 equation(s) in 6 unknown variable(s). Tear the system of equations:
    Tearing  variables: der(w2)
    Residual equations:
       7: J2 * der(w2) = tau2
    All unknowns are solved.
Teared equation system is linear. Solve system with hasConstantCoefficients = false.
code = quote
    local var&quot;der(w2)&quot;, var&quot;der(der(phi2))&quot;, var&quot;der(der(phi1))&quot;, var&quot;der(w1)&quot;, tau1, tau2
    _leq_mode = initLinearEquationsIteration!(_m, 1)
     ModiaBase.TimerOutputs.@timeit _m.timer &quot;ModiaBase LinearEquationsIteration!&quot; while ModiaBase.LinearEquationsIteration!(_leq_mode, _m.isInitial, _m.solve_leq, _m.storeResult, _m.time, _m.timer)
            var&quot;der(w2)&quot; = _leq_mode.x[1] * u&quot;s^-1&quot;
            var&quot;der(der(phi2))&quot; = var&quot;der(w2)&quot;
            var&quot;der(der(phi1))&quot; = _FloatType(_p[:ratio])::_FloatType * var&quot;der(der(phi2))&quot;
            var&quot;der(w1)&quot; = var&quot;der(der(phi1))&quot;
            tau1 = -((_FloatType(_p[:J1])::_FloatType * var&quot;der(w1)&quot; - tau))
            tau2 = _FloatType(_p[:ratio])::_FloatType * tau1
            ModiaBase.appendVariable!(_leq_mode.residuals, Modia.Unitful.ustrip.(tau2) .- Modia.Unitful.ustrip.(_FloatType(_p[:J2])::_FloatType * var&quot;der(w2)&quot;))
        end
    _leq_mode = nothing
end
Sort equations (BLT on all equations under the assumption that the ODE states are known).

Information message from getSortedAndSolvedAST for model TwoInertiasAndIdealGearTooManyInits:
The following variables are iteration variables but have no start/init values defined.
If units are used in the model, start/init values with correct units should be defined
to avoid unit errors during compilation.
Involved variables:
    der(w2)


Warning message from getSortedAndSolvedAST for model TwoInertiasAndIdealGearTooManyInits:
The following variables have an &#39;init&#39; initialization and are explicitly solved for.
Therefore, the &#39;init&#39; values have no effect, but must exactly match the values,
computed during initialization. Otherwise this gives a run-time error.
It is adviced to use &#39;start&#39; initialization or remove initialization for these variables.
Involved variables:
    phi1
    w1</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Modeling.html">« 2 Modeling</a><a class="docs-footer-nextpage" href="FloatingPointTypes.html">4 Floating Point Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Tuesday 5 July 2022 12:31">Tuesday 5 July 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
